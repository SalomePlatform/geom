// Copyright (C) 2007-2024  CEA, EDF, OPEN CASCADE
//
// Copyright (C) 2003-2007  OPEN CASCADE, EADS/CCR, LIP6, CEA/DEN,
// CEDRAT, EDF R&D, LEG, PRINCIPIA R&D, BUREAU VERITAS
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
//
// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
//
//  File   : GEOM_Gen.idl
//  Author : Sergey RUIN

#ifndef __GEOM_GEN__
#define __GEOM_GEN__

#include "SALOME_Exception.idl"
#include "SALOME_Component.idl"
#include "SALOMEDS.idl"
#include "SALOMEDS_Attributes.idl"

#include "SALOME_GenericObj.idl"

module GEOM
{
  /*!
   *  \brief Topological types of shapes (like Open Cascade types)
   */
  enum shape_type 
  { 
    /*! A collection of arbitrary shapes */
    COMPOUND,
    /*! A collection of solids */ 
    COMPSOLID, 
    /*! A part of 3D space bound by a shell */
    SOLID, 
    /*! A collection of faces connected by some edges of their wire boundaries */
    SHELL,
    /*! Part of a plane (in 2D geometry) or a surface (in 3D geometry) bounded by a closed wire */
    FACE, 
    /*! A sequence of edges connected by their vertices */
    WIRE, 
    /*! Edge, a shape corresponding to a curve, and bound by a vertex at each extremity */
    EDGE, 
    /*! A zero-dimensional shape corresponding to a point in geometry */
    VERTEX,
    /*! Arbitrary shape in a Compound (used for processing of Compounds in some operations) */ 
    SHAPE,
    /*! Flat (top-level) contents of a Compound (used for processing of Compounds in some operations) */
    FLAT
    };

  /*!
   * \brief Marker type
   */
  enum marker_type { MT_NONE, MT_POINT, MT_PLUS, MT_STAR, MT_X, MT_O, MT_O_POINT, MT_O_PLUS,
                     MT_O_STAR, MT_O_X, MT_RING1, MT_RING2, MT_RING3, MT_BALL, MT_USER };

  /*!
   * /brief Marker size
   */
  enum marker_size { MS_NONE, MS_10, MS_15, MS_20, MS_25, MS_30, MS_35,
                     MS_40, MS_45, MS_50, MS_55, MS_60, MS_65, MS_70 };

  /*!
   *  \brief State of shape relatively geometrical surface like plane, sphere or cylinder.
   *
   *  Is used in functions GEOM_IShapesOperations.GetShapesOn<xxx>()
   */
  enum shape_state
  {
    /*! Shape is on surface */
    ST_ON,

    /*!
     *  Shape is in the direction defined by the normal and not on surface.
     *  For plane it means above the plane,
     *  For sphere and cylinder it means outside of volume, bounded by the surface.
     */
    ST_OUT,
    
    /*!
     *  Shape is in the direction defined by the normal and on surface.
     *  ONOUT = ON || OUT
     */
    ST_ONOUT,

    /*!
     *  Complementary to ONOUT.
     *  For plane it means below the plane,
     *  For sphere and cylinder it means inside the volume, bounded by the surface
     *  (beyond axis and surface for cylinder and beyond cented and surface for sphere).
     */
    ST_IN,

    /*!
     *  Complementary to OUT.
     *  ONIN = ON || IN
     */
    ST_ONIN
  };

  /*!
   *  \brief Kind of method to find inside one main shape some sub-shapes,
   *  corresponding to other given shape (its argument)
   *
   *  Is used in functions GEOM_Gen.RestoreSubShapesO(), GEOM_Gen.RestoreSubShapesSO(),
   *  TransferNames()
   */
  enum find_shape_method
  {
    /*! Use GetInPlace functionality. Suits all cases, except transformations */
    FSM_GetInPlace,

    /*! To be used only for transformation result, to find sub-shapes of argument.
     *  Only this method can be used after transformation.
     */
    FSM_Transformed,

    /*! To find only shared sub-shapes, not modified by the operation */
    FSM_GetSame,

    /*! Use GetShapesOnShape method (can work only on solids) */
    FSM_GetShapesOnShape,

    /*! Use GetInPlaceByHistory method (can work only after Partition) */
    FSM_GetInPlaceByHistory,

    /*! To be used only for multi-transformation result.
     *  Only this method can be used after multi-transformation.
     */
    FSM_MultiTransformed,

    /*! Use old GetInPlace functionality. */
    FSM_GetInPlace_Old
  };

  /*!
   *  \brief Kind of method to perform filling operation
   *
   *  Is used in functions GEOM_I3DPrimOperations.MakeFilling()
   */
  enum filling_oper_method
  {
    /*! Default (standard behaviour) */
    FOM_Default,

    /*! Use edges orientation  - orientation of edges is used: if the edge is 
     * reversed, the curve from this edge is reversed before using it in 
     *  the filling algorithm.
     */
    FOM_UseOri,

    /*! Auto-correct edges orientation - changes the orientation of the curves 
     *  using minimization of sum of distances between the end points of the edges.
     */
    FOM_AutoCorrect
  };

  /*!
   * \brief Kind of the curves.
   *
   * Used in the functions GEOM_ICurvesOperations.MakeCurveParametric(), GEOM_ICurvesOperations.MakeCurveParametricNew(),
   * GEOM_ICurvesOperations.MakePolyline2D, GEOM_ICurvesOperations.MakePolyline2DOnPlane.
   */
  enum curve_type {
    /*! Polyline curve */
    Polyline,
    
    /*! Bezier curve */
    Bezier,

    /*! Interpolation, curve */
    Interpolation
  };

 /*!
   * \brief Type of field data
   */
  enum field_data_type {
    FDT_Bool,
    FDT_Int,
    FDT_Double,
    FDT_String
  };

  /**
   * This enumeration represents the level of checking shape on
   * self-interference. It defines which interferferences will be checked.
   */
  enum si_check_level
  {
    SI_V_V,     // only V/V interferences
    SI_V_E,     // V/V and V/E interferences
    SI_E_E,     // V/V, V/E and E/E interferences
    SI_V_F,     // V/V, V/E, E/E and V/F interferences
    SI_E_F,     // V/V, V/E, E/E, V/F and E/F interferences
    SI_ALL      // all interferences
  };

  /**
   * This enumeration represents comparison conditions.
   */
  enum comparison_condition
  {
    CC_GT, ///< Greater then
    CC_GE, ///< Greater then or equal to
    CC_LT, ///< Less then
    CC_LE  ///< Less then or equal to
  };

  /*!
   *  \brief Wire construction mode. Regulates the way gaps are closed.
   *
   *  Is used in function GEOM_IShapesOperations.MakeWire()
   */
  enum wire_build_mode
  {
    /*! Do not change curves, just enlarge wire tolerance to cover the gaps */
    WBM_FixTolerance,

    /*!
     *  Replace curves, neighbour to the gap,
     *  with BSplines, connecting in the middle of the gap
     */
    WBM_Approximation,

    /*!
     *  Replace curves, neighbour to the gap, with new curves of the same
     *  type and close parameters, connecting in the middle of the gap
     */
    WBM_KeepCurveType
  };

  /*!
   * \brief Object creation parameters
   *
   * Is returned by GEOM_Object::GetCreationInformation()
   */
  struct Parameter
  {
    string name;
    string value;
  };
  typedef sequence<Parameter> Parameters;

  struct CreationInformation
  {
    string     operationName;
    Parameters params;
  };
  typedef sequence<CreationInformation> CreationInformationSeq;

  /*!
   * \brief Reporting on shape healing
   */
  struct ModifInfo
  {
    string name;  // what changed
    long   count; // how many times
  };
  typedef sequence<ModifInfo> ModifStatistics;


  typedef sequence<string>       string_array;
  typedef sequence<short>        short_array;
  typedef sequence<boolean>      ListOfBool;
  typedef sequence<long>         ListOfLong;
  typedef sequence<double>       ListOfDouble;
  typedef sequence<ListOfDouble> ListOfListOfDouble;
  typedef sequence<ListOfLong>   ListOfListOfLong;

  interface GEOM_Gen;
  interface GEOM_Object;
  interface GEOM_BaseObject;
  interface GEOM_Field;
  interface GEOM_FieldStep;

  typedef sequence<GEOM_Object>       ListOfGO;
  typedef sequence<GEOM_BaseObject>   ListOfGBO;
  typedef sequence<GEOM_Field>        ListOfFields;
  typedef sequence<SALOMEDS::SObject> object_list;

  //# GEOM_BaseObject
  /*!
   *  \brief A common root of objects in GEOM module
   */
  interface GEOM_BaseObject : SALOME::GenericObj
  {
    /*!
     *  \brief Set name of the object.
     *
     *  \param theName is a name which will be associated with this object.
     */
    void SetName (in string theName);

    /*!
    *  \brief Get name of the object associated with this object.
     */
    string GetName();

    /*!
     *  \brief Get internal (unique) entry of the object in the GEOM component's data tree.
     *  \note This is not an entry of the data object in SALOME study. 
     *  This is internal function of GEOM component, though it can be used outside it for 
        appropriate reason (e.g. for unique identification of geometry object).
     */
    string GetEntry();

    /*!
     *  \brief Get internal type of operation created this object (POINT, BOX, CYLINDER, EXTRUSION...).
     *  \note To get topological information on the object, use \ref GEOM_IMeasureOperations::WhatIs() "WhatIs()"
     * or \ref GEOM_IMeasureOperations::KindOfShape() "KindOfShape()" operation.
     */
    long GetType();

    /*!
     *  \brief Get value of a modification counter of the object
     */
    long GetTick();

    /*!
     *  \brief Set a Study entry where this object was published.
     */
    void SetStudyEntry (in string theEntry);

    /*!
     *  \brief Get a Study entry where this object was published.
     */
    string GetStudyEntry();

    /*!
     *  \brief Get a list of all GEOM_Object on which were the arguments
     *  when this object was constructed and modified.
     *  \note This method is supposed to be used by GUI only.
     */
    ListOfGBO GetDependency();

    /*!
     *  \brief Get a list of GEOM_Object on which the last function that created or modified the object depends.
     *  \note This method is supposed to be used by GUI only.
     */
    ListOfGBO GetLastDependency();

    /*
     *  \brief Return true if geom object representes a shape.
     *
     *  For example, method return false for GEOM_MARKER
     */
     boolean IsShape();

    /*
     *  \brief Return true if passed object is identical to this object
     *
     *  \param other object being compared with this one
     */
    boolean IsSame(in GEOM_BaseObject other);

     /*!
     *  Set list of parameters
     *  \param theParameters is a string containing the notebook variables separated by ":" symbol,
     *         used for object creation
     */
    void SetParameters (in string theParameters);

    /*!
     *  \brief Return list of notebook variables used for object creation separated by ":" symbol
     */
    string GetParameters();

    /*!
     * \brief Return name of operation and values of parameters used for object creation
     */
    CreationInformationSeq GetCreationInformation();

    /*!
     * \brief Return the engine creating this object
     */
    GEOM_Gen GetGen();
  };

  //# GEOM_Object
  /*!
   *  \brief Interface of geometric object
   */
  interface GEOM_Object : GEOM_BaseObject
  {
    /*!
     *  \brief Get a <VAR>shape_type</VAR> of the object value.
     */
    shape_type GetShapeType();

    /*!
     *  \brief Get the topology type of the object value.
     *
     *  In contrast to the shape type, this function returns type of the most
     *  top-level sub-shape of the COMPOUND or COMPSOLID, if there is only one
     *  sub-shape there.
     *  \sa GetShapeType()
     */
    shape_type GetTopologyType();

    /*!
     *  \brief Get a minimal type of the top-level shapes contained in the object.
     *
     *  This function is useful for the compounds only; for simple shapes it
     *  exactly the same value as GetShapeType().
     *  Note, that compounds are processed recursively.
     *
     *  \sa GetShapeType(), GetTopologyType(), GetMaxShapeType()
     */
    shape_type GetMinShapeType();

    /*!
     *  \brief Get a maximal type of the top-level shapes contained in the object.
     *
     *  This function is useful for the compounds only; for simple shapes it
     *  exactly the same value as GetShapeType().
     *  Note, that compounds are processed recursively.
     *
     *  \sa GetShapeType(), GetTopologyType(), GetMinShapeType()
     */
    shape_type GetMaxShapeType();

    /*!
     *  \brief Returns a name of a sub-shape if the sub-shape is published in the study
     *  \param subID - sub-shape ID
     *  \return string - the found name or an empty string if the sub-shape does not
     *          exits or is not published in the study
     *
     * \note Only sub-shapes directly retrieved (using e.g. ExtractSubShapes() or
     *       via group creation) can be found. Also, as sub-shape can be published in the study
     *       many times, only the first found name is returned.
     */
    string GetSubShapeName(in long subID);

    /*!
     *  \brief Set color of the object.
     *
     *  \param theColor is a color of the object.
     */
    void SetColor(in SALOMEDS::Color theColor);

    /*!
     *  Get color of the object.
     */
    SALOMEDS::Color GetColor();

    /*!
     *  Toggle auto color mode on the object.
     *  \param theAutoColor is a flag which toggles auto color mode.
     */
    void SetAutoColor(in boolean theAutoColor);

    /*!
     *  \brief Get flag of object's auto color mode.
     */
    boolean GetAutoColor();

    /*!
     * \brief Set standard point marker for the object
     * \param theType standard marker type
     * \param theSize marker relative size
     */
    void SetMarkerStd(in marker_type theType, in marker_size theSize );

    /*!
     * \brief Set custom point marker for the object. 
     *
     * The texture can be added by LoadTexture() or AddTexture() functions.
     * \param theTextureId texture ID
     */
    void SetMarkerTexture(in long theTextureId);

    /*!
     * \brief Get type of the point marker assigned to the object
     * \return current marker type (MT_NONE if no marker is set)
     */
    marker_type GetMarkerType();

    /*!
     * \brief Get size of the point marker assigned to the object
     * \return current marker relative size (MS_NONE if no marker is set)
     */
    marker_size GetMarkerSize();

    /*!
     * \brief Get texture idenifier of the point marker assigned to the object
     * \return marker texture ID (0 if no marker set)
     */
    long GetMarkerTexture();

    /*!
     *  \brief Get the TopoDS_Shape, for colocated case only.
     */
    long long getShape();

 //   ######################################################################
 //   # Internal methods (For sub-shape identification)
 //   ######################################################################
    /*!
     *  \brief Get geometric shape of the object as a byte stream in BRep format
     *  \note GEOM_IInsertOperations::RestoreShape() method can be used to restore shape from a BRep stream.
     */
    SALOMEDS::TMPFile GetShapeStream();

    /*
     *  \brief Returns True if this object is not a sub-shape of another object.
     */
    boolean IsMainShape();

    /*
     *  \brief Get a list of ID's of sub-shapes in the main shape.
     *  \note Internal method, suppopsed to be used only by GEOM_Client
     */
    ListOfLong GetSubShapeIndices();

    /*
     *  \brief Get a main shape object to which this object is a sub-shape
     *  \note Internal method, suppopsed to be used only by GEOM_Client
     */
    GEOM_Object GetMainShape();

    /*
     * \brief Returns true if the current object has connection to a parametrical model
     * which can be modified by parameters change.
     */
    boolean IsParametrical();

  };

  //# GEOM_Field
  /*!
   *  \brief Interface of the field
   */
  interface GEOM_Field : GEOM_BaseObject
  {
    /*!
     *  \brief Returns the shape the field lies on
     */
    GEOM_Object GetShape();

    /*!
     *  \brief Returns type of field data
     */
    field_data_type GetDataType();

    /*!
     *  \brief Returns dimension of the shape the field lies on
     *  0 - VERTEX, 1 - EDGE, 2 - FACE, 3 - SOLID, -1 - whole shape
     */
    short GetDimension();

    /*!
     *  \brief Returns names of components
     */
    string_array GetComponents();

    /*!
     *  \brief Removes a component. Component number counts from one.
     */
    //void RemoveComponent(in long number);

    /*!
     *  \brief Adds a time step to the field
     */
    GEOM_FieldStep AddStep(in long stepID, in long stamp);

    /*!
     *  \brief Remove a time step from the field
     */
    void RemoveStep(in long stepID);

    /*!
     *  \brief Returns number of time steps in the field
     */
    long CountSteps();

    /*!
     *  \brief Returns a list of time step IDs in the field
     */
    ListOfLong GetSteps();

    /*!
     *  \brief Returns a time step by its ID
     */
    GEOM_FieldStep GetStep(in long stepID);

    /*!
     *  \brief Returns a size of data array that is to be passed to
     *         GEOM_FieldStep.SetValues( dataArray ). This size depends on the
     *         number of sub-shapes of field dimension and the number of components
     */
    long GetArraySize();
  };

  // # GEOM_FieldStep:
  /*!
   *  \brief Interface of the field time step
   */
  interface GEOM_FieldStep : GEOM_BaseObject
  {
    /*!
     *  \brief Changes the time of the field step
     */
    void SetStamp(in long stamp);

    /*!
     *  \brief Returns the time of the field step
     */
    long GetStamp();

    /*!
     *  \brief Returns the number of the field step
     */
    long GetID();

    /*!
     *  \brief Returns the field the step belongs to
     */
    GEOM_Field GetField();
  };

  // # GEOM_BoolFieldStep:
  /*!
   *  \brief Interface of the boolean field time step
   */
  interface GEOM_BoolFieldStep : GEOM_FieldStep
  {
    /*!
     *  \brief Changes values of the field step. Returns false if number of values is wrong
     */
    boolean SetValues(in short_array boolValues);

    /*!
     *  \brief Returns values of the field step
     */
    short_array GetValues();
  };

  // # GEOM_IntFieldStep:
  /*!
   *  \brief Interface of the integer field time step
   */
  interface GEOM_IntFieldStep : GEOM_FieldStep
  {
    /*!
     *  \brief Changes values of the field step. Returns false if number of values is wrong
     */
    boolean SetValues(in ListOfLong intValues);

    /*!
     *  \brief Returns values of the field step
     */
    ListOfLong GetValues();
  };

  // # GEOM_DoubleFieldStep:
  /*!
   *  \brief Interface of the double field time step
   */
  interface GEOM_DoubleFieldStep : GEOM_FieldStep
  {
    /*!
     *  \brief Changes values of the field step. Returns false if number of values is wrong
     */
    boolean SetValues(in ListOfDouble doubleValues);

    /*!
     *  \brief Returns values of the field step
     */
    ListOfDouble GetValues();
  };

  // # GEOM_StringFieldStep:
  /*!
   *  \brief Interface of the string field time step
   */
  interface GEOM_StringFieldStep : GEOM_FieldStep
  {
    /*!
     *  \brief Changes values of the field step. Returns false if number of values is wrong
     */
    boolean SetValues(in string_array strValues);

    /*!
     *  \brief Returns values of the field step
     */
    string_array GetValues();
  };

  // # GEOM_IOperations:
  /*!
   *  \brief Basic methods of all geometric operations
   */
  interface GEOM_IOperations : SALOME::GenericObj
  {
    /*!
     *  \brief To know, if the operation was successfully performed
     */
    boolean IsDone();

    /*!
     *  \brief Set the operation error code
     *  \param theErrorID is a string describing the error occurred
     *  \note This method is supposed to be used only by interfaces inheriting from IOperations.
     */
    void SetErrorCode (in string theErrorID);

    /*!
     *  \brief Get the operation error code
     */
    string GetErrorCode();

    /*!
     *  \brief Opens a new transaction
     */
    void StartOperation();

    /*!
     *  \brief Closes the previously opened transaction
     */
    void FinishOperation();

    /*!
     *  \brief Aborts the previously opened transaction
     */
    void AbortOperation();
  };
  //# GEOM_IBasicOperations:
  /*!
   *  \brief Interface for basic geometry creation
   *
   *  (Point, Vector, Plane, Marker)
   */
  interface GEOM_IBasicOperations : GEOM_IOperations
  {
    /*!
     *  \brief Create point by three coordinates.
     *  \param theX The X coordinate of the point.
     *  \param theY The Y coordinate of the point.
     *  \param theZ The Z coordinate of the point.
     *  \return New GEOM_Object, containing the created point.
     */
    GEOM_Object MakePointXYZ (in double theX, in double theY, in double theZ);

    /*!
     *  \brief Create a point, distant from the referenced point
     *  on the given distances along the coordinate axes.
     *  \param theReference The referenced point.
     *  \param theX Displacement from the referenced point along OX axis.
     *  \param theY Displacement from the referenced point along OY axis.
     *  \param theZ Displacement from the referenced point along OZ axis.
     *  \return New GEOM_Object, containing the created point.
     */
    GEOM_Object MakePointWithReference (in GEOM_Object theReference,
                                        in double theX, in double theY, in double theZ);

    /*!
     *  Create a point, corresponding to the given parameter on the given curve.
     *  \param theRefCurve The referenced curve.
     *  \param theParameter Value of parameter on the referenced curve.
     *  \param takeOrientationIntoAccount flag that tells if it is necessary
     *         to take the curve's orientation into account.
     *  \return New GEOM_Object, containing the created point.
     */
    GEOM_Object MakePointOnCurve (in GEOM_Object theRefCurve,
                                  in double      theParameter,
                                  in boolean     takeOrientationIntoAccount);

    /*!
     *  \brief Create a point, corresponding to the given length on the given curve.
     *  \param theRefCurve The referenced curve.
     *  \param theLength Length on the referenced curve. It can be negative.
     *  \param theStartPoint Any vertex close to one of edge's
     *                       ends to select start point among them.
     *                       If NULL, fist vertex is used.
     *  \return New GEOM_Object, containing the created point.
     */
    GEOM_Object MakePointOnCurveByLength (in GEOM_Object theRefCurve,
                                          in double      theLength,
                                          in GEOM_Object theStartPoint);

    /*!
     *  \brief Create a point on the given curve, projecting given point
     *  \param theRefCurve The referenced curve.
     *  \param theXParameter X co-ordinate of point to project on curve
     *  \param theYParameter Y co-ordinate of point to project on curve
     *  \param theZParameter Z co-ordinate of point to project on curve
     *  \return New GEOM_Object, containing the created point.
     */
    GEOM_Object MakePointOnCurveByCoord (in GEOM_Object theRefCurve,
                                         in double theXParameter,
                                         in double theYParameter,
                                         in double theZParameter);

    /*!
     *  \brief Create a point, corresponding to the given parameters on the
     *    given surface.
     *  \param theRefSurf The referenced surface.
     *  \param theUParameter Value of U-parameter on the referenced surface.
     *  \param theVParameter Value of V-parameter on the referenced surface.
     *  \return New GEOM_Object, containing the created point.
     */
    GEOM_Object MakePointOnSurface (in GEOM_Object theRefSurf,
                                    in double theUParameter,
                                    in double theVParameter);

    /*!
     *  \brief Create a point on the given surface, projecting given point
     *  \param theRefSurf The referenced surface.
     *  \param theXParameter X co-ordinate of point to project on curve
     *  \param theYParameter Y co-ordinate of point to project on curve
     *  \param theZParameter Z co-ordinate of point to project on curve
     *  \return New GEOM_Object, containing the created point.
     */
    GEOM_Object MakePointOnSurfaceByCoord (in GEOM_Object theRefSurf,
                                           in double theXParameter,
                                           in double theYParameter,
                                           in double theZParameter);

    /*!
     *  \brief Create a point, which lays on the given face.
     *         The point will lay in arbitrary place of the face.
     *         The only condition on it is a non-zero distance to the face boundary.
     *         Such point can be used to uniquely identify the face inside any
     *         shape in case, when the shape does not contain overlapped faces.
     *  \param theFace The referenced face.
     *  \return New GEOM_Object, containing the created point.
     */
    GEOM_Object MakePointOnFace (in GEOM_Object theFace,
				 in long        theNumberOfPnts);

    /*!
     *  \brief Create a point, on two lines intersection.
     *  \param theRefLine1, theRefLine2 The referenced lines.
     *  \return New GEOM_Object, containing the created point.
     */
    GEOM_Object MakePointOnLinesIntersection (in GEOM_Object theRefLine1,
                                              in GEOM_Object theRefLine2);

     /*!
     *  \brief Create a vector, corresponding to tangent to the given parameter on the given curve.
     *  \param theRefCurve The referenced curve.
     *  \param theParameter Value of parameter on the referenced curve.This value should be have value
     *                      between 0. and 1.. Value of 0. corresponds first parameter of curve; value
     *                      1. corresponds last parameter of curve.
     *  \return New GEOM_Object, containing the created point.
     */
     GEOM_Object MakeTangentOnCurve (in GEOM_Object theRefCurve,
                                     in double theParameter);

    /*!
     *  \brief Create a vector with the given components.
     *  \param theDX X component of the vector.
     *  \param theDY Y component of the vector.
     *  \param theDZ Z component of the vector.
     *  \return New GEOM_Object, containing the created vector.
     */
    GEOM_Object MakeVectorDXDYDZ (in double theDX,
                                  in double theDY,
                                  in double theDZ);

    /*!
     *  \brief Create a vector between two points.
     *  \param thePnt1 Start point for the vector.
     *  \param thePnt2 End point for the vector.
     *  \return New GEOM_Object, containing the created vector.
     */
    GEOM_Object MakeVectorTwoPnt (in GEOM_Object thePnt1, in GEOM_Object thePnt2);

    /*!
     *  \brief Create a line, passing through the given point
     *  and parallel to the given direction
     *  \param thePnt Point. The resulting line will pass through it.
     *  \param theDir Direction. The resulting line will be parallel to it.
     *  \return New GEOM_Object, containing the created line.
     */
    GEOM_Object MakeLine (in GEOM_Object thePnt, in GEOM_Object theDir);

    /*!
     *  \brief Create a line, passing through the given points
     *  \param thePnt1 First of two points, defining the line.
     *  \param thePnt2 Second of two points, defining the line.
     *  \return New GEOM_Object, containing the created line.
     */
    GEOM_Object MakeLineTwoPnt (in GEOM_Object thePnt1, in GEOM_Object thePnt2);

    /*!
     *  \brief Create a line, given by two faces intersection.
     *  \param theFace1 First of two faces, defining the line.
     *  \param theFace2 Second of two faces, defining the line.
     *  \return New GEOM_Object, containing the created line.
     */
    GEOM_Object MakeLineTwoFaces (in GEOM_Object theFace1, in GEOM_Object theFace2);

    /*!
     *  \brief Create a plane, passing through the three given points
     *  \param thePnt1 First of three points, defining the plane.
     *  \param thePnt2 Second of three points, defining the plane.
     *  \param thePnt3 Third of three points, defining the plane.
     *  \param theTrimSize Half size of a side of quadrangle face, representing the plane.
     *  \return New GEOM_Object, containing the created plane.
     */
    GEOM_Object MakePlaneThreePnt (in GEOM_Object thePnt1,
                                   in GEOM_Object thePnt2,
                                   in GEOM_Object thePnt3,
                                   in double theTrimSize);

    /*!
     *  \brief Create a plane, passing through the given point
     *  and normal to the given vector.
     *  \param thePnt Point, the plane has to pass through.
     *  \param theVec Vector, defining the plane normal direction.
     *  \param theTrimSize Half size of a side of quadrangle face, representing the plane.
     *  \return New GEOM_Object, containing the created plane.
     */
    GEOM_Object MakePlanePntVec (in GEOM_Object thePnt,
                                 in GEOM_Object theVec,
                                 in double theTrimSize);

    /*!
     *  \brief Create a plane, similar to the existing one, but with another size of representing face.
     *  \param theFace Referenced plane or LCS(Marker).
     *  \param theTrimSize New half size of a side of quadrangle face, representing the plane.
     *  \return New GEOM_Object, containing the created plane.
     */
    GEOM_Object MakePlaneFace (in GEOM_Object theFace,
                               in double theTrimSize);

    /*!
     *  \brief Create a plane, by two vectors.
     *  \param theVec1 Vector1, the plane has to pass through first point of this vector.
     *  \param theVec2 Vector2, defining the plane normal direction.
     *  \param theTrimSize Half size of a side of quadrangle face, representing the plane.
     *  \return New GEOM_Object, containing the created plane.
     */
    GEOM_Object MakePlane2Vec (in GEOM_Object theVec1,
                               in GEOM_Object theVec2,
                               in double theTrimSize);

    /*!
     *  \brief Create a plane, defined by local coordinate system.
     *  \param theLCS Referenced LCS(Marker).
     *  \param theTrimSize Half size of a side of quadrangle face, representing the plane.
     *  \param theOrientation OXY, OYZ or OZX orientation = (1, 2 or 3).
     *  \return New GEOM_Object, containing the created plane.
     */
    GEOM_Object MakePlaneLCS (in GEOM_Object theLCS,
                              in double theTrimSize,
                              in double theOrientation);

    /*!
     *  \brief Create a local coordinate system.
     *  \param theOX,theOY,theOZ Three coordinates of coordinate system origin.
     *  \param theXDX,theXDY,theXDZ Three components of OX direction
     *  \param theYDX,theYDY,theYDZ Three components of OY direction
     *  \return New GEOM_Object, containing the created coordinate system.
     */
    GEOM_Object MakeMarker (in double theOX , in double theOY , in double theOZ,
                            in double theXDX, in double theXDY, in double theXDZ,
                            in double theYDX, in double theYDY, in double theYDZ);

    /*!
     *  \brief Create a local coordinate system from shape.
     *  \param theShape The initial shape to detect the coordinate system.
     *  \return New GEOM_Object, containing the created coordinate system.
     */
    GEOM_Object MakeMarkerFromShape (in GEOM_Object theShape);

    /*!
     *  \brief Create a local coordinate system from point and two vectors (DX, DY).
     *  \param theOrigin Point of coordinate system origin.
     *  \param theXVec Vector of X direction.
     *  \param theYVec Vector of Y direction.
     *  \return New GEOM_Object, containing the created coordinate system.
     */
    GEOM_Object MakeMarkerPntTwoVec (in GEOM_Object theOrigin,
                                     in GEOM_Object theXVec, in GEOM_Object theYVec);

    /*!
     *  \brief Create a tangent plane to specified face in the point with specified parameters.
     *
     *  Values of parameters should be between 0. and 1.0
     *  \param theFace - face for which tangent plane shuold be built.
     *  \param theParameterU - value of parameter by U
     *  \param theParameterV - value of parameter Vthe
     *  \param theTrimSize - defines sizes of created face
     *  \return New GEOM_Object, containing the face built on tangent plane.
     */
    GEOM_Object MakeTangentPlaneOnFace(in GEOM_Object theFace,
                                       in double theParameterU,
                                       in double theParameterV,
                                       in double theTrimSize);
  };

  /*!
   *  \brief Interface for shapes transforming.
   *
   *  Translation, rotation, scaling, mirroring, offset, projection, recomputing.
   */
  interface GEOM_ITransformOperations : GEOM_IOperations
  {
    /*!
     *  \brief Translate the given object along the vector, specified by its end points.
     *  \param theObject The object to be translated.
     *  \param thePoint1 Start point of translation vector.
     *  \param thePoint2 End point of translation vector.
     *  \return theObject.
     */
    GEOM_Object TranslateTwoPoints (in GEOM_Object theObject,
                                    in GEOM_Object thePoint1,
                                    in GEOM_Object thePoint2);

    /*!
     *  \brief Translate the given object along the vector, specified
     *  by its end points, creating its copy before the translation.
     *  \param theObject The object to be translated.
     *  \param thePoint1 Start point of translation vector.
     *  \param thePoint2 End point of translation vector.
     *  \return New GEOM_Object, containing the translated object.
     */
    GEOM_Object TranslateTwoPointsCopy (in GEOM_Object theObject,
                                        in GEOM_Object thePoint1,
                                        in GEOM_Object thePoint2);

    /*!
     *  \brief Translate the given object along the vector, specified by its components.
     *  \param theObject The object to be translated.
     *  \param theDX,theDY,theDZ Components of translation vector.
     *  \return theObject.
     */
    GEOM_Object TranslateDXDYDZ (in GEOM_Object theObject,
                                 in double theDX, in double theDY, in double theDZ);

    /*!
     *  \brief Translate the given object along the vector, specified
     *  by its components, creating its copy before the translation.
     *  \param theObject The object to be translated.
     *  \param theDX,theDY,theDZ Components of translation vector.
     *  \return New GEOM_Object, containing the translated object.
     */
    GEOM_Object TranslateDXDYDZCopy (in GEOM_Object theObject,
                                     in double theDX, in double theDY, in double theDZ);


    /*!
     *  \brief Translate the given object along the given vector.
     *  \param theObject The object to be translated.
     *  \param theVector Translation vector, giving both direction and distance.
     *  \return theObject.
     */
    GEOM_Object TranslateVector (in GEOM_Object theObject,
                                 in GEOM_Object theVector);

    /*!
     *  \brief Translate the given object along the given vector,
     *  creating its copy before the translation.
     *  \param theObject The object to be translated.
     *  \param theVector Translation vector, giving both direction and distance.
     *  \return New GEOM_Object, containing the translated object.
     */
    GEOM_Object TranslateVectorCopy (in GEOM_Object theObject,
                                     in GEOM_Object theVector);

    /*!
     *  \brief Translate the given object along the given vector on given distance,
     *  creating its copy before the translation.
     *  \param theObject The object to be translated.
     *  \param theVector Translation vector, giving a direction.
     *  \param theDistance Translation distance, giving a distance.
     *  \param theCopy Translation copy, creating its copy if true.
     *  \return New GEOM_Object, containing the translated object.
     */
    GEOM_Object TranslateVectorDistance (in GEOM_Object theObject,
                                         in GEOM_Object theVector,
                                         in double      theDistance,
                                         in boolean     theCopy);

    /*!
     *  \brief Translate the given object along the given vector a given number times
     *  \param theObject The object to be translated.
     *  \param theVector Direction of the translation. DX if None.
     *  \param theStep Distance to translate on.
     *  \param theNbTimes Quantity of translations to be done.
     *  \return New GEOM_Object, containing compound of all
     *          the shapes, obtained after each translation.
     */
    GEOM_Object MultiTranslate1D (in GEOM_Object theObject,
                                  in GEOM_Object theVector,
                                  in double theStep,
                                  in long theNbTimes);

    /*!
     *  \brief Conseqently apply two specified translations to theObject specified number of times.
     *  \param theObject The object to be translated.
     *  \param theVector1 Direction of the first translation. DX if None.
     *  \param theStep1 Step of the first translation.
     *  \param theNbTimes1 Quantity of translations to be done along theVector1.
     *  \param theVector2 Direction of the second translation. DY if None.
     *  \param theStep2 Step of the second translation.
     *  \param theNbTimes2 Quantity of translations to be done along theVector2.
     *  \return New GEOM_Object, containing compound of all
     *          the shapes, obtained after each translation.
     */
    GEOM_Object MultiTranslate2D (in GEOM_Object theObject,
                                  in GEOM_Object theVector1,
                                  in double theStep1,
                                  in long theNbTimes1,
                                  in GEOM_Object theVector2,
                                  in double theStep2,
                                  in long theNbTimes2);

    /*!
     *  \brief Rotate given object around vector perpendicular to plane containing three points.
     *  \param theObject The object to be rotated.
     *  \param theCentPoint central point - the axis is the vector perpendicular to the plane
     *                      containing the three points.
     *  \param thePoint1,thePoint2 - in a perpendicular plan of the axis.
     *  \return theObject.
     */
    GEOM_Object RotateThreePoints (in GEOM_Object theObject,
                                   in GEOM_Object theCentPoint,
                                   in GEOM_Object thePoint1,
                                   in GEOM_Object thePoint2);


    /*!
     *  \brief Rotate given object around vector perpendicular to plane containing three points.
     *
     *  Creating its copy before the rotatation.
     *  \param theObject The object to be rotated.
     *  \param theCentPoint central point - the axis is the vector perpendicular to the plane
     *  containing the three points.
     *  \param thePoint1,thePoint2 - in a perpendicular plan of the axis.
     *  \return New GEOM_Object, containing the rotated object.
     */
    GEOM_Object RotateThreePointsCopy (in GEOM_Object theObject,
                                       in GEOM_Object theCentPoint,
                                       in GEOM_Object thePoint1,
                                       in GEOM_Object thePoint2);

    /*!
     *  \brief Rotate the given object around the given axis on the given angle.
     *  \param theObject The object to be rotated.
     *  \param theAxis Rotation axis.
     *  \param theAngle Rotation angle in radians.
     *  \return theObject.
     */
    GEOM_Object Rotate (in GEOM_Object theObject,
                        in GEOM_Object theAxis,
                        in double theAngle);


    /*!
     *  Rotate the given object around the given axis
     *  on the given angle, creating its copy before the rotatation.
     *  \param theObject The object to be rotated.
     *  \param theAxis Rotation axis.
     *  \param theAngle Rotation angle in radians.
     *  \return New GEOM_Object, containing the rotated object.
     */
    GEOM_Object RotateCopy (in GEOM_Object theObject,
                            in GEOM_Object theAxis,
                            in double theAngle);

    /*!
     *  \brief Rotate the given object around the given axis a given number times.
     *
     *  Rotation angle will be 2*PI/theNbObjects.
     *  \param theObject The object to be rotated.
     *  \param theAxis The rotation axis. DZ if None.
     *  \param theNbObjects Quantity of rotations to be done.
     *  \return New GEOM_Object, containing compound of all the
     *          shapes, obtained after each rotation.
     */
    GEOM_Object MultiRotate1D (in GEOM_Object theObject,
                               in GEOM_Object theAxis,
                               in long theNbObjects);

    /*!
     *  \brief Rotate the given object around the given axis
     *         a given number times on the given angle.
     *
     *  \param theObject The object to be rotated.
     *  \param theAxis The rotation axis. DZ if None.
     *  \param theAngleStep Rotation angle in radians.
     *  \param theNbSteps Quantity of rotations to be done.
     *  \return New GEOM_Object, containing compound of all the
     *          shapes, obtained after each rotation.
     */
    GEOM_Object MultiRotate1DByStep (in GEOM_Object theObject,
                                     in GEOM_Object theAxis,
                                     in double theAngleStep,
                                     in long theNbSteps);

    /*!
     *  \brief Rotate the given object around the given axis
     *  a given number times and multi-translate each rotation result.
     *
     *  Rotation angle will be 2*PI/theNbObjects.
     *  Translation direction passes through center of gravity
     *  of rotated shape and its projection on the rotation axis.
     *  \param theObject The object to be rotated.
     *  \param theAxis Rotation axis. DZ if None.
     *  \param theNbObjects Quantity of rotations to be done.
     *  \param theRadialStep Translation distance.
     *  \param theNbSteps Quantity of translations to be done.
     *  \return New GEOM_Object, containing compound of all the
     *          shapes, obtained after each transformation.
     */
    GEOM_Object MultiRotate2DNbTimes (in GEOM_Object theObject,
                                      in GEOM_Object theAxis,
                                      in long theNbObjects,
                                      in double theRadialStep,
                                      in long theNbSteps);

    /*!
     *  \brief Rotate the given object around the
     *  given axis on the given angle a given number
     *  times and multi-translate each rotation result.
     *
     *  Translation direction passes through center of gravity
     *  of rotated shape and its projection on the rotation axis.
     *  \param theObject The object to be rotated.
     *  \param theAxis Rotation axis. DZ if None.
     *  \param theAngleStep Rotation angle in radians.
     *  \param theNbSteps1 Quantity of rotations to be done.
     *  \param theRadialStep Translation distance.
     *  \param theNbSteps2 Quantity of translations to be done.
     *  \return New GEOM_Object, containing compound of all the
     *          shapes, obtained after each transformation.
     */
    GEOM_Object MultiRotate2DByStep (in GEOM_Object theObject,
                                     in GEOM_Object theAxis,
                                     in double theAngleStep,
                                     in long theNbSteps1,
                                     in double theRadialStep,
                                     in long theNbSteps2);

    /*!
     *  \brief Rotate the given object around the
     *  given axis on the given angle a given number
     *  times and multi-translate each rotation result.
     *
     *  Translation direction passes through center of gravity
     *  of rotated shape and its projection on the rotation axis.
     *  \param theObject The object to be rotated.
     *  \param theAxis Rotation axis. DZ if None.
     *  \param theAngleStep Rotation angle in degrees.
     *  \param theNbSteps1 Quantity of rotations to be done.
     *  \param theRadialStep Translation distance.
     *  \param theNbSteps2 Quantity of translations to be done.
     *  \return New GEOM_Object, containing compound of all the
     *          shapes, obtained after each transformation.
     */
    GEOM_Object MultiRotate2D (in GEOM_Object theObject,
                               in GEOM_Object theAxis,
                               in double theAngleStep,
                               in long theNbSteps1,
                               in double theRadialStep,
                               in long theNbSteps2);

    /*!
     *  \brief Replace the given object by an object,
     *  symmetrical to it relatively the given plane.
     *  \param theObject The object to be mirrored.
     *  \param thePlane Plane of symmetry.
     */
    GEOM_Object MirrorPlane (in GEOM_Object theObject, in GEOM_Object thePlane);

    /*!
     *  \brief Create an object, symmetrical
     *  to the given one relatively the given plane.
     *  \param theObject The object to be mirrored.
     *  \param thePlane Plane of symmetry.
     *  \return New GEOM_Object, containing the mirrored shape.
     */
    GEOM_Object MirrorPlaneCopy (in GEOM_Object theObject, in GEOM_Object thePlane);

    /*!
     *  \brief Replace the given object by an object,
     *  symmetrical to it relatively the given axis.
     *  \param theObject The object to be mirrored.
     *  \param theAxis Axis of symmetry.
     *  \return theObject.
     */
    GEOM_Object MirrorAxis (in GEOM_Object theObject, in GEOM_Object theAxis);

    /*!
     *  \brief Create an object, symmetrical
     *  to the given one relatively the given axis.
     *  \param theObject The object to be mirrored.
     *  \param theAxis Axis of symmetry.
     *  \return New GEOM_Object, containing the mirrored object.
     */
    GEOM_Object MirrorAxisCopy (in GEOM_Object theObject, in GEOM_Object theAxis);

    /*!
     *  \brief Replace the given object by an object, symmetrical to it relatively the given point.
     *  \param theObject The object to be mirrored.
     *  \param thePoint Point of symmetry.
     *  \return theObject.
     */
    GEOM_Object MirrorPoint (in GEOM_Object theObject, in GEOM_Object thePoint);

    /*!
     *  \brief Create an object, symmetrical to the given one relatively the given point.
     *  \param theObject The object to be mirrored.
     *  \param thePoint Point of symmetry.
     *  \return New GEOM_Object, containing the mirrored object.
     */
    GEOM_Object MirrorPointCopy (in GEOM_Object theObject, in GEOM_Object thePoint);

    /*!
     *  \brief Replace the given object by its offset.
     *  \param theObject The base object for the offset.
     *  \param theOffset Offset value.
     *  \param theJoinByPipes To join offset surfaces by pipes or by intersection.
     *  \return theObject.
     */
    GEOM_Object OffsetShape (in GEOM_Object theObject,
                             in double      theOffset,
                             in boolean     theJoinByPipes);

    /*!
     *  \brief Create new object as offset of the given one.
     *  \param theObject The base object for the offset.
     *  \param theOffset Offset value.
     *  \param theJoinByPipes To join offset surfaces by pipes or by intersection.
     *  \return New GEOM_Object, containing the offset object.
     */
    GEOM_Object OffsetShapeCopy (in GEOM_Object theObject,
                                 in double      theOffset,
                                 in boolean     theJoinByPipes);

    /*!
     *  \brief Create new object as projection of the given one on a 2D surface.
     *  \param theSource The source object for the projection. It can be a point, edge or wire.
     *  \param theTarget The target object. It can be planar or cylindrical face.
     *  \return New GEOM_Object, containing the projection.
     */
    GEOM_Object ProjectShapeCopy (in GEOM_Object theSource, in GEOM_Object theTarget);

    /*!
     *  \brief Create a projection projection of the given point on a wire or
     *  an edge.
     *
     *  If there are no solutions or there are 2 or more solutions It throws an
     *  exception.
     *  \param thePoint the point to be projected.
     *  \param theWire the wire. The edge is accepted as well.
     *  \param thePointOnEdge the projection point.
     *  \param theEdgeInWireIndex the index of an edge in a wire.
     *  \return the parameter of projection point on edge.
     */
    double ProjectPointOnWire (in  GEOM_Object thePoint,
                               in  GEOM_Object theWire,
                               out GEOM_Object thePointOnEdge,
                               out long        theEdgeInWireIndex);

    /*!
     *  \brief Scale the given object by the factor.
     *  \param theObject The object to be scaled.
     *  \param thePoint Center point for scaling.
     *  \param theFactor Scaling factor value.
     *  \return theObject.
     */
    GEOM_Object ScaleShape (in GEOM_Object theObject, in GEOM_Object thePoint,
                            in double theFactor);

    /*!
     *  \brief Scale the given object by the factor, creating its copy before the scaling.
     *  \param theObject The object to be scaled.
     *  \param thePoint Center point for scaling.
     *  \param theFactor Scaling factor value.
     *  \return New GEOM_Object, containing the scaled shape.
     */
    GEOM_Object ScaleShapeCopy (in GEOM_Object theObject, in GEOM_Object thePoint,
                                in double theFactor);

    /*!
     *  \brief Scale the given object by different factors along coordinate axes.
     *  \param theObject The object to be scaled.
     *  \param thePoint Center point for scaling.
     *  \param theFactorX,theFactorY,theFactorZ Scaling factors along each axis.
     *  \return theObject.
     */
    GEOM_Object ScaleShapeAlongAxes (in GEOM_Object theObject,
                                     in GEOM_Object thePoint,
                                     in double theFactorX,
                                     in double theFactorY,
                                     in double theFactorZ);

    /*!
     *  \brief Scale the given object by different factors along coordinate axes,
     *  creating its copy before the scaling.
     *  \param theObject The object to be scaled.
     *  \param thePoint Center point for scaling.
     *  \param theFactorX,theFactorY,theFactorZ Scaling factors along each axis.
     *  \return New GEOM_Object, containing the scaled shape.
     */
    GEOM_Object ScaleShapeAlongAxesCopy (in GEOM_Object theObject,
                                         in GEOM_Object thePoint,
                                         in double theFactorX,
                                         in double theFactorY,
                                         in double theFactorZ);

    /*!
     *  \brief Modify the Location of the given object by LCS.
     *  \param theObject The object to be displaced.
     *  \param theStartLCS Coordinate system to perform displacement from it.
     *                     If \a theStartLCS is NULL, displacement
     *                     will be performed from global CS.
     *                     If \a theObject itself is used as \a theStartLCS,
     *                     its location will be changed to \a theEndLCS.
     *  \param theEndLCS Coordinate system to perform displacement to it.
     *  \return theObject.
     */
    GEOM_Object PositionShape (in GEOM_Object theObject,
                               in GEOM_Object theStartLCS,
                               in GEOM_Object theEndLCS);

    /*!
     *  \brief Modify the Location of the given object by LCS,
     *  creating its copy before the setting.
     *  \param theObject The object to be displaced.
     *  \param theStartLCS Coordinate system to perform displacement from it.
     *                     If \a theStartLCS is NULL, displacement
     *                     will be performed from global CS.
     *                     If \a theObject itself is used as \a theStartLCS,
     *                     its location will be changed to \a theEndLCS.
     *  \param theEndLCS Coordinate system to perform displacement to it.
     *  \return New GEOM_Object, containing the displaced shape.
     */
    GEOM_Object PositionShapeCopy (in GEOM_Object theObject,
                                   in GEOM_Object theStartLCS,
                                   in GEOM_Object theEndLCS);

    /*!
     *  \brief Modify the Location of the given object by Path,
     *  \param  theObject The object to be displaced.
     *  \param  thePath Wire or Edge along that the object will be translated.
     *  \param  theDistance progress of Path (0 = actual location, 1 = end of path location).
     *  \param  theCopy is a true or false parameter. true is to create a copy, false to move the object.
     *  \param  theReverse is a true or false parameter. True is to reverse
     *                     direction, false is to move normal direction.
     *  \return New GEOM_Object, containing the displaced shape.
     */
    GEOM_Object PositionAlongPath (in GEOM_Object theObject,
                                   in GEOM_Object thePath,
                                   in double theDistance,
                                   in boolean theCopy,
                                   in boolean theReverse);

    /*!
     *  \brief Recompute the shape from its arguments.
     *  \param theObject The object to be recomputed.
     *  \return theObject.
     */
    GEOM_Object RecomputeObject (in GEOM_Object theObject);

    /*!
     *  \brief Compute the projection of a wire or a face on a cylinder.
     *
     *  This method computes a wire or a face or a compound of faces
     *  that represents a projection of the source shape onto cylinder.
     *  The cylinder's coordinate system is the same as the global coordinate
     *  system.
     *
     *  \param theObject The object to be projected. It can be either
     *         a planar wire or a face.
     *  \param theRadius The radius of the cylinder.
     *  \param theStartAngle The starting angle from the cylinder's X axis
     *         around Z axis. The angle from which the projection is started.
     *  \param theAngleLength The projection length angle. The angle in which
     *         to project the total length of the wire. If it is negative the
     *         projection is not scaled and natural wire length is kept for
     *         the projection.
     *  \param theAngleRotation the desired angle between the tangent vector
     *         to the first curve at the first point of the theObject's
     *         projection in 2D space and U-direction of cylinder's 2D space.
     *  \return A wire or a face or a compound of faces that represents a
     *         projection of the source shape onto a cylinder.
     */
    GEOM_Object MakeProjectionOnCylinder (in GEOM_Object theObject,
                                          in double      theRadius,
                                          in double      theStartAngle,
                                          in double      theAngleLength,
                                          in double      theAngleRotation);
  };
  
  /*!
   *  \brief Interface for 3D primitives creation
   *
   *  Box, Cylinder, Cone, Sphere, Prism (extrusion),
   *  Pipe (extrusion along contour), Revolution, Solid (from shell).
   */
  interface GEOM_I3DPrimOperations : GEOM_IOperations
  {
    /*!
     *  \brief Create a box with specified dimensions along the coordinate axes
     *  and with edges, parallel to the coordinate axes.
     *
     *  Center of the box will be at point (DX/2, DY/2, DZ/2).
     *  \param theDX Length of Box edges, parallel to OX axis.
     *  \param theDY Length of Box edges, parallel to OY axis.
     *  \param theDZ Length of Box edges, parallel to OZ axis.
     *  \return New GEOM_Object, containing the created box.
     */
    GEOM_Object MakeBoxDXDYDZ (in double theDX, in double theDY, in double theDZ);

    /*!
     *  \brief Create a box with two specified opposite vertices,
     *  and with edges, parallel to the coordinate axes
     *  \param thePnt1 First of two opposite vertices.
     *  \param thePnt2 Second of two opposite vertices.
     *  \return New GEOM_Object, containing the created box.
     */
    GEOM_Object MakeBoxTwoPnt (in GEOM_Object thePnt1, in GEOM_Object thePnt2);

    /*!
     *  \brief Create a face specified dimensions along OX-OY coordinate axes,
     *  with edges parallel to the coordinate axes.
     *
     *  Center of the face will be at point (0, 0, 0).
     *  \param theH Height of the Face.
     *  \param theW Width of the Face.
     *  \param theOrientation Orientation belong axis OXY OYZ OZX
     *  \return New GEOM_Object, containing the created face.
     */
    GEOM_Object MakeFaceHW (in double theH, in double theW, in short theOrientation);
    /*!
     *  \brief Create a face by normale vector or edge and two specified sizes,
     *  vertical (H) and horisontal (W).
     *  \param theObj defines plane.
     *  \param theH vertical size (height).
     *  \param theW horisontal size (width).
     *  \return New GEOM_Object, containing the created face.
     */
    GEOM_Object MakeFaceObjHW (in GEOM_Object theObj, in double theH, in double theW);
    /*!
     *  \brief Create a Disk (circular face) with given center, normal vector and radius.
     *  \param thePnt disk center.
     *  \param theVec Vector, normal to the plane of the disk.
     *  \param theR Disk radius.
     *  \return New GEOM_Object, containing the created disk.
     */
    GEOM_Object MakeDiskPntVecR (in GEOM_Object thePnt,
                                 in GEOM_Object theVec,
                                 in double theR);
    /*!
     *  \brief Create a disk (circular face), passing through three given points
     *  \param thePnt1, thePnt2, thePnt3 Points, defining the disk.
     *  \return New GEOM_Object, containing the created disk.
     */
    GEOM_Object MakeDiskThreePnt (in GEOM_Object thePnt1,
                                  in GEOM_Object thePnt2,
                                  in GEOM_Object thePnt3);

    /*!
     *  \brief Create a disk specified dimensions along OX-OY coordinate axes.
     *
     *  Center of the disk at point (0, 0, 0).
     *  \param theR of the Disk.
     *  \param theOrientation Orientation belong axis OXY OYZ OZX
     *  \return New GEOM_Object, containing the created disk.
     */
    GEOM_Object MakeDiskR (in double theR, in short theOrientation);

    /*!
     *  \brief Create a cylinder with given radius and height at
     *  the origin of coordinate system.
     *
     *  Axis of the cylinder will be collinear to the OZ axis of the coordinate system.
     *  \param theR Cylinder radius.
     *  \param theH Cylinder height.
     *  \return New GEOM_Object, containing the created cylinder.
     */
    GEOM_Object MakeCylinderRH (in double theR, in double theH);

    /*!
     *  \brief Create a portion of cylinder with given radius, height and angle at
     *  the origin of coordinate system.
     *
     *  Axis of the cylinder will be collinear to the OZ axis of the coordinate system.
     *  \param theR Cylinder radius.
     *  \param theH Cylinder height.
     *  \param theA Cylinder angle.
     *  \return New GEOM_Object, containing the created cylinder.
     */
    GEOM_Object MakeCylinderRHA (in double theR, in double theH, in double theA);

    /*!
     *  \brief Create a cylinder with given base point, axis, radius and height.
     *  \param thePnt Central point of cylinder base.
     *  \param theAxis Cylinder axis.
     *  \param theR Cylinder radius.
     *  \param theH Cylinder height.
     *  \return New GEOM_Object, containing the created cylinder.
     */
    GEOM_Object MakeCylinderPntVecRH (in GEOM_Object thePnt,
                                      in GEOM_Object theAxis,
                                      in double      theR,
                                      in double      theH);
    /*!
     *  \brief Create a portion of cylinder with given base point, axis, radius, height and angle.
     *  \param thePnt Central point of cylinder base.
     *  \param theAxis Cylinder axis.
     *  \param theR Cylinder radius.
     *  \param theH Cylinder height.
     *  \param theA Cylinder angle.
     *  \return New GEOM_Object, containing the created cylinder.
     */
    GEOM_Object MakeCylinderPntVecRHA (in GEOM_Object thePnt,
                                      in GEOM_Object theAxis,
                                      in double      theR,
                                      in double      theH,
                                      in double      theA);

    /*!
     *  \brief Create a cone with given height and radiuses at
     *  the origin of coordinate system. 
     *
     *  Axis of the cone will be collinear to the OZ axis of the coordinate system.
     *  \param theR1 Radius of the first cone base.
     *  \param theR2 Radius of the second cone base.
     *    \note If both radiuses are non-zero, the cone will be truncated.
     *    \note If the radiuses are equal, a cylinder will be created instead.
     *  \param theH Cone height.
     *  \return New GEOM_Object, containing the created cone.
     */
    GEOM_Object MakeConeR1R2H (in double theR1, in double theR2, in double theH);

    /*!
     *  \brief Create a cone with given base point, axis, height and radiuses.
     *  \param thePnt Central point of the first cone base.
     *  \param theAxis Cone axis.
     *  \param theR1 Radius of the first cone base.
     *  \param theR2 Radius of the second cone base.
     *    \note If both radiuses are non-zero, the cone will be truncated.
     *    \note If the radiuses are equal, a cylinder will be created instead.
     *  \param theH Cone height.
     *  \return New GEOM_Object, containing the created cone.
     */
    GEOM_Object MakeConePntVecR1R2H (in GEOM_Object thePnt,
                                     in GEOM_Object theAxis,
                                     in double      theR1,
                                     in double      theR2,
                                     in double      theH);

    /*!
     *  \brief Create a torus with given radiuses at the origin of coordinate system.
     *  \param theRMajor Torus major radius.
     *  \param theRMinor Torus minor radius.
     *  \return New GEOM_Object, containing the created torus.
     */
    GEOM_Object MakeTorusRR (in double theRMajor,
                             in double theRMinor);

    /*!
     *  \brief Create a torus with given center, normal vector and radiuses.
     *  \param thePnt Torus central point.
     *  \param theVec Torus axis of symmetry.
     *  \param theRMajor Torus major radius.
     *  \param theRMinor Torus minor radius.
     *  \return New GEOM_Object, containing the created torus.
     */
    GEOM_Object MakeTorusPntVecRR (in GEOM_Object thePnt,
                                   in GEOM_Object theVec,
                                   in double theRMajor,
                                   in double theRMinor);

    /*!
     *  \brief Create a sphere with given radius at the origin of coordinate system.
     *  \param theR Sphere radius.
     *  \return New GEOM_Object, containing the created sphere.
     */
    GEOM_Object MakeSphereR (in double theR);

    /*!
     *  \brief Create a sphere with given center and radius.
     *  \param thePnt Sphere center.
     *  \param theR Sphere radius.
     *  \return New GEOM_Object, containing the created .
     */
    GEOM_Object MakeSpherePntR (in GEOM_Object thePnt, in double theR);

    /*!
     *  \brief Create a shape by extrusion of the base shape along the vector
     *
     *  All the space, transfixed by the base shape during its translation
     *  along the vector on the given distance.
     *  \param theBase Base shape to be extruded.
     *  \param theVec Direction of extrusion.
     *  \param theH Prism dimension along theVec.
     *  \return New GEOM_Object, containing the created prism.
     */
    GEOM_Object MakePrismVecH (in GEOM_Object theBase,
                               in GEOM_Object theVec,
                               in double      theH);
    /*  \brief The Same Prism but in 2 directions (forward&backward) */
    GEOM_Object MakePrismVecH2Ways (in GEOM_Object theBase,
                                    in GEOM_Object theVec,
                                    in double      theH);
    /*  \brief The Same as MakePrismVecH but with scaling */
    GEOM_Object MakePrismVecHWithScaling (in GEOM_Object theBase,
                                          in GEOM_Object theVec,
                                          in double      theH,
                                          in double      theScaleFactor);

    /*!
     *  \brief Create a shape by extrusion of the base shape along a vector, defined by two points.
     *  \param theBase Base shape to be extruded.
     *  \param thePoint1 First end of extrusion vector.
     *  \param thePoint2 Second end of extrusion vector.
     *  \return New GEOM_Object, containing the created prism.
     */
    GEOM_Object MakePrismTwoPnt (in GEOM_Object theBase,
                                 in GEOM_Object thePoint1,
                                 in GEOM_Object thePoint2);
    /*  \brief The same prism but in two directions forward&backward */
    GEOM_Object MakePrismTwoPnt2Ways (in GEOM_Object theBase,
                                      in GEOM_Object thePoint1,
                                      in GEOM_Object thePoint2);
    /*  \brief The Same as MakePrismTwoPnt but with scaling */
    GEOM_Object MakePrismTwoPntWithScaling (in GEOM_Object theBase,
                                            in GEOM_Object thePoint1,
                                            in GEOM_Object thePoint2,
                                            in double      theScaleFactor);

    /*!
     *  \brief Create a shape by extrusion of the base shape along a vector, defined by DX DY DZ.
     *  \param theBase Base shape to be extruded.
     *  \param theDX, theDY, theDZ end of extrusion vector.
     *  \return New GEOM_Object, containing the created prism.
     */
    GEOM_Object MakePrismDXDYDZ (in GEOM_Object theBase,
                                   in double theDX, in double theDY, in double theDZ);
    /*  \brief The same prism but in two directions forward&backward */
    GEOM_Object MakePrismDXDYDZ2Ways (in GEOM_Object theBase,
                                      in double theDX, in double theDY, in double theDZ);
    /*  \brief The Same as MakePrismDXDYDZ but with scaling */
    GEOM_Object MakePrismDXDYDZWithScaling (in GEOM_Object theBase,
                                            in double theDX, in double theDY, in double theDZ,
                                            in double theScaleFactor);


    /*!
     *  \brief Add / Remove material to / from a solid by extrusion of the base shape on the given distance.
     *  \param theInitShape Initial shape on which to perform the feature.It has to be a solid or 
     *   a compound made of a single solid
     *  \param theBase Edge or wire defining the base shape to be extruded. 
     *  \param theHeight Prism dimension along the normal of the face.
     *  \param theAngle Draft angel in degrees
     *  \param theFuse If true material is added else material is removed
     *  \param theInvert If true material changes the direction 
     *  \return New GEOM_Object, containing the modified shape
     */
    GEOM_Object MakeDraftPrism (in GEOM_Object theInitShape,
                                in GEOM_Object theBase,
                                in double theHeight, 
                                in double theAngle,
                                in boolean theFuse,
                                in boolean theInvert);

    /*!
     *  \brief Create a shape by extrusion of the base shape along
     *  the path shape. The path shape can be a wire or an edge.
     *  \param theBase Base shape to be extruded.
     *  \param thePath Path shape to extrude the base shape along it.
     *  \param IsGenerateGroups flag that tells if it is necessary to
     *         return groups (true) or not (false).
     *  \return The list of objects. The first one is a result pipe,
     *          the other ones are the created groups. If \a IsGenerateGroups
     *          is not set the returned list contains a single object, which
     *          is the operation result.
     */
    ListOfGO MakePipe (in GEOM_Object theBase,
                       in GEOM_Object thePath,
                       in boolean     IsGenerateGroups);

    /*!
     *  \brief Create a shape by revolution of the base shape around the axis
     *  on the given angle. 
     *
     *  All the space, transfixed by the base
     *  shape during its rotation around the axis on the given angle.
     *  \param theBase Base shape to be rotated.
     *  \param theAxis Rotation axis.
     *  \param theAngle Rotation angle in radians.
     *  \return New GEOM_Object, containing the created revolution.
     */
    GEOM_Object MakeRevolutionAxisAngle (in GEOM_Object theBase,
                                         in GEOM_Object theAxis,
                                         in double theAngle);
    /*  The Same Revolution but in both ways forward&backward */
    GEOM_Object MakeRevolutionAxisAngle2Ways (in GEOM_Object theBase,
                                              in GEOM_Object theAxis,
                                              in double theAngle);

    /*!
     *  \brief Create a face from a given set of contours.
     *  \param theContours either a list or a compound of edges/wires.
     *  \param theMinDeg a minimal degree of BSpline surface to create.
     *  \param theMaxDeg a maximal degree of BSpline surface to create.
     *  \param theTol2D a 2d tolerance to be reached.
     *  \param theTol3D a 3d tolerance to be reached.
     *  \param theNbIter a number of iteration of approximation algorithm.
     *  \param theMethod Kind of method to perform filling operation.
     *  \param theApprox Boolean indicating if result should be approximated.
     *  \return New GEOM_Object (face), containing the created filling surface.
     */
    GEOM_Object MakeFilling (in ListOfGO theContours,
                             in long theMinDeg, in long theMaxDeg,
                             in double theTol2D, in double theTol3D,
                             in long theNbIter,
                             in filling_oper_method theMethod,
                             in boolean theApprox);

    /*!
     *  \brief Create a shell or solid passing through set of sections.Sections should be wires,edges or vertices.
     *  \param theSeqSections - set of specified sections.
     *  \param theModeSolid - mode defining building solid or shell
     *  \param thePreci - precision 3D used for smoothing by default 1.e-6
     *  \param theRuled - mode defining type of the result surfaces (ruled or smoothed).
     *  \return New GEOM_Object, containing the created shell or solid.
     */
    GEOM_Object MakeThruSections(in ListOfGO theSeqSections,
                                 in boolean theModeSolid,
                                 in double thePreci,
                                 in boolean theRuled);

     /*!
     *  \brief Create a shape by extrusion of the profile shape along
     *  the path shape. 
     *
     *  The path shape can be a wire or an edge.
     *  the several profiles can be specified in the several locations of path.
     *  \param theSeqBases - list of Bases shape to be extruded.
     *  \param theLocations - list of locations on the path corresponding
     *                        specified list of the Bases shapes. Number of locations
     *                        should be equal to number of bases or list of locations can be empty.
     *  \param thePath - Path shape to extrude the base shape along it.
     *  \param theWithContact - the mode defining that the section is translated to be in
     *                          contact with the spine. Ignored if IsBySteps is set.
     *  \param theWithCorrection - defining that the section is rotated to be
     *                                 orthogonal to the spine tangent in
     *                          the correspondent point. Ignored if IsBySteps is set.
     *  \param IsBySteps - flag that tells if the result should be created
     *         step by step or as a whole. If IsBySteps is set no correction
     *         of bases is allowed.
     *  \param IsGenerateGroups flag that tells if it is necessary to
     *         return groups (true) or not (false).
     *  \return The list of objects. The first one is a result pipe,
     *          the other ones are the created groups. If \a IsGenerateGroups
     *          is not set the returned list contains a single object, which
     *          is the operation result.
     */
    ListOfGO MakePipeWithDifferentSections (in ListOfGO theSeqBases,
                                            in ListOfGO theLocations,
                                            in GEOM_Object thePath,
                                            in boolean theWithContact ,
                                            in boolean theWithCorrection,
                                            in boolean IsBySteps,
                                            in boolean IsGenerateGroups);

    /*!
     *  \brief Create a shape by extrusion of the profile shape along
     *  the path shape. 
     *
     *  The path shape can be a shell or a face.
     *  the several profiles can be specified in the several locations of path.
     *  \param theSeqBases - list of Bases shape to be extruded.
     *  \param theSeqSubBases - list of corresponding sub-shapes of section shapes.
     *  \param theLocations - list of locations on the path corresponding
     *                        specified list of the Bases shapes. Number of locations
     *                        should be equal to number of bases.
     *  \param thePath - Path shape to extrude the base shape along it.
     *  \param theWithContact - the mode defining that the section is translated to be in
     *                          contact with the spine.
     *  \param theWithCorrection - defining that the section is rotated to be
     *                                 orthogonal to the spine tangent in the correspondent point
     *  \param IsGenerateGroups flag that tells if it is necessary to
     *         return groups (true) or not (false).
     *  \return The list of objects. The first one is a result pipe,
     *          the other ones are the created groups. If \a IsGenerateGroups
     *          is not set the returned list contains a single object, which
     *          is the operation result.
     */
    ListOfGO MakePipeWithShellSections (in ListOfGO theSeqBases,
                                        in ListOfGO theSeqSubBases,
                                        in ListOfGO theLocations,
                                        in GEOM_Object thePath,
                                        in boolean theWithContact,
                                        in boolean theWithCorrection,
                                        in boolean IsGenerateGroups);

    /*!
     *  \brief Create solids between given sections
     *  \param theSeqBases - list of sections (shell or face).
     *  \param theLocations - list of corresponding vertexes
     *  \param IsGenerateGroups flag that tells if it is necessary to
     *         return groups (true) or not (false).
     *  \return The list of objects. The first one is a result pipe,
     *          the other ones are the created groups. If \a IsGenerateGroups
     *          is not set the returned list contains a single object, which
     *          is the operation result.
     */
    ListOfGO MakePipeShellsWithoutPath (in ListOfGO theSeqBases,
                                        in ListOfGO theLocations,
                                        in boolean  IsGenerateGroups);

    /*!
     *  \brief Create a shape by extrusion of the base shape along
     *  the path shape with constant bi-normal direction along the given vector.
     *
     *  The path shape can be a wire or an edge.
     *  \param theBase Base shape to be extruded.
     *  \param thePath Path shape to extrude the base shape along it.
     *  \param theVec Vector defines a constant binormal direction to keep the
     *                same angle between the Direction and the sections
     *                along the sweep surface.
     *  \param IsGenerateGroups flag that tells if it is necessary to
     *         return groups (true) or not (false).
     *  \return The list of objects. The first one is a result pipe,
     *          the other ones are the created groups. If \a IsGenerateGroups
     *          is not set the returned list contains a single object, which
     *          is the operation result.
     */
    ListOfGO MakePipeBiNormalAlongVector (in GEOM_Object theBase,
                                          in GEOM_Object thePath,
                                          in GEOM_Object theVec,
                                          in boolean     IsGenerateGroups);


     /*!
     *  \brief Make a thick solid from a shape.
     *
     *  If the input is a surface shape (face or shell) the result is
     *  a thick solid. If an input shape is a solid the result is a hollowed
     *  solid with removed faces.
     *  \param theObject face or shell to get thick solid or solid to get
     *         hollowed solid.
     *  \param theFacesIDs the list of face IDs to be removed from the result.
     *          It can be empty.
     *  \param theThickness Value of the thickness
     *  \param isCopy To make a copy of \a theObject or to modify \a theObject
     *  \param isInside If true the thickness is applied towards inside
     *  \return New GEOM_Object, containing the created pipe if isCopy = true
     *          or the modified object if isCopy = false
     */
    GEOM_Object MakeThickening (in GEOM_Object theObject,
                                in ListOfLong  theFacesIDs,
                                in double      theThickness,
                                in boolean     isCopy,
                                in boolean     isInside);

    
    /*!
     *  \brief Build a middle path of a pipe-like shape.
     *
     *  The path shape can be a wire or an edge.
     *  \param theShape It can be closed or unclosed pipe-like shell
     *                  or a pipe-like solid.
     *  \param theBase1, theBase2 Two bases of the supposed pipe. This
     *                            should be wires or faces of \a theShape.
     *  \note It is not assumed that exact or approximate copy of \a theShape
     *        can be obtained by applying existing Pipe operation on the
     *        resulting "Path" wire taking \a theBase1 as the base - it is not
     *        always possible; though in some particular cases it might work
     *        it is not guaranteed. Thus, RestorePath function should not be
     *        considered as an exact reverse operation of the Pipe.
     *  \return New GEOM_Object, containing an edge or wire that represent
     *                           source pipe's "path".
     */
    GEOM_Object RestorePath (in GEOM_Object theShape,
                             in GEOM_Object theBase1,
                             in GEOM_Object theBase2);

    /*!
     *  \brief Build a middle path of a pipe-like shape.
     *
     *  The path shape can be a wire or an edge.
     *  \param theShape It can be closed or unclosed pipe-like shell
     *                  or a pipe-like solid.
     *  \param theBase1, theBase2 Two bases of the supposed pipe. This
     *                            should be lists of edges of \a theShape.
     *  \note It is not assumed that exact or approximate copy of \a theShape
     *        can be obtained by applying existing Pipe operation on the
     *        resulting "Path" wire taking \a theBase1 as the base - it is not
     *        always possible; though in some particular cases it might work
     *        it is not guaranteed. Thus, RestorePath function should not be
     *        considered as an exact reverse operation of the Pipe.
     *  \return New GEOM_Object, containing an edge or wire that represent
     *                           source pipe's "path".
     */
    GEOM_Object RestorePathEdges (in GEOM_Object theShape,
                                  in ListOfGO theBase1,
                                  in ListOfGO theBase2);
  };

  /*!
   *  \brief Interface for Shapes creation:
   *
   *  Edge from two points, Wire from edges, Face from wire,
   *  Shell from faces, Solid from shells, Compound from shapes
   */
  interface GEOM_IShapesOperations : GEOM_IOperations
  {
    /*!
     *  \brief Create a linear edge with specified ends.
     *  \param thePnt1 Point for the first end of edge.
     *  \param thePnt2 Point for the second end of edge.
     *  \return New GEOM_Object, containing the created edge.
     */
    GEOM_Object MakeEdge (in GEOM_Object thePnt1, in GEOM_Object thePnt2);

    /*!
     *  \brief Create an edge on another edge, corresponding to the given length on the given edge.
     *  \param theRefCurve The referenced edge.
     *  \param theLength Length on the referenced edge. It can be
     *                   negative for extrapolation on base curve.
     *  \param theStartPoint Any vertex close to one of edge's
     *                       ends to select start point among them.
     *                       If NULL, fist vertex is used.
     *  \return New GEOM_Object, containing the created edge.
     */
    GEOM_Object MakeEdgeOnCurveByLength (in GEOM_Object theRefCurve,
                                         in double      theLength,
                                         in GEOM_Object theStartPoint);

    /*!
     *  \brief Create an edge from specified wire.
     *  \param theWire source Wire.
     *  \param theLinearTolerance linear tolerance value
     *  \param theAngularTolerance angular tolerance value
     *  \return New GEOM_Object, containing the created edge.
     */
    GEOM_Object MakeEdgeWire (in GEOM_Object theWire,
                              in double theLinearTolerance,
                              in double theAngularTolerance);

    /*!
     *  \brief Create a wire from the set of edges and wires.
     *  \param theEdgesAndWires List of edge and/or wires.
     *  \param theTolerance Maximum distance between vertices, that will be merged.
     *                      Values less than 1e-07 are equivalent to 1e-07 (Precision::Confusion()).
     *  \param theMode Mode of gaps filling.
     *  \return New GEOM_Object, containing the created wire.
     */
    GEOM_Object MakeWire (in ListOfGO theEdgesAndWires,
                          in double   theTolerance,
                          in wire_build_mode theMode);

    /*!
     *  \brief Create a face on the given wire.
     *  \param theWire closed Wire or Edge to build the face on.
     *  \param isPlanarWanted If TRUE, only planar face will be built.
     *                        If impossible, NULL object will be returned.
     *  \return New GEOM_Object, containing the created face.
     */
    GEOM_Object MakeFace (in GEOM_Object theWire, in boolean isPlanarWanted);

    /*!
     *  \brief Create a face on the given wires set.
     *  \param theWires List of closed wires or edges to build the face on.
     *  \param isPlanarWanted If TRUE, only planar face will be built.
     *                        If impossible, NULL object will be returned.
     *  \return New GEOM_Object, containing the created face.
     */
    GEOM_Object MakeFaceWires (in ListOfGO theWires, in boolean isPlanarWanted);

    /**
     *  \brief Create a face based on surface of theFace limited by theWire.
     *  \param theFace the face whose surface is used to create a new face.
     *  \param theWire closed Wire build the face.
     *  \return New GEOM_Object, containing the created face.
     */
    GEOM_Object MakeFaceFromSurface(in GEOM_Object theFace,
                                    in GEOM_Object theWire);

    /**
     *  \brief Create non planar face with list of edges and list of vertices
     *  \param theEdges list of Edges(must be closed but not nesessarily belong to the same plane) .
     *  \param theVertices list of vertices through which the result face must pass.
     *  \param theTolerance tolerance.
     *  \return New GEOM_Object, containing the created face.
     */
    GEOM_Object MakeWrappedFace(in ListOfGO theEdges,
                                in ListOfGO theVertices,
                                in double   theTolerance);

    /*!
     *  \brief Create a face from a set of edges with the given constraints.
     *  \param theConstraints List of edges and constraint faces (as a sequence of a Edge + Face couples):
     *         - edges should form a closed wire;
     *         - for each edge, constraint face is optional: if a constraint face is missing
     *           for some edge, this means that there no constraint associated with this edge.
     *  \return New GEOM_Object, containing the created face.
     */
    GEOM_Object MakeFaceWithConstraints(in ListOfGO theConstraints);

    /*!
     *  \brief Create a shell from the set of faces and shells.
     *  \param theFacesAndShells List of faces and/or shells.
     *  \return New GEOM_Object, containing the created shell.
     */
    GEOM_Object MakeShell (in ListOfGO theFacesAndShells);

    /*!
     *  \brief Create a solid, bounded by the given shell.
     *  \param theShell Bounding shell.
     *  \return New GEOM_Object, containing the created solid.
     */
    GEOM_Object MakeSolidShell (in GEOM_Object theShell);

    /*!
     *  \brief Create a solid, bounded by the given shells.
     *  \param theShells Bounding shells.
     *  \return New GEOM_Object, containing the created solid.
     */
    GEOM_Object MakeSolidShells (in ListOfGO theShells);

    /*!
     *  \brief Create a compound of the given shapes.
     *  \param theShapes List of shapes to put in compound.
     *  \return New GEOM_Object, containing the created compound.
     */
    GEOM_Object MakeCompound (in ListOfGO theShapes);

    /*!
     *  \brief Make a solid (or solids) from connected set of faces and/or shells.
     *  \param theFacesOrShells List of faces and/or shells.
     *  \param isIntersect If TRUE, forces performing intersections between arguments.
     *
     *  \return New GEOM_Object, containing the created solid (or compound of solids).
     */
    GEOM_Object MakeSolidFromConnectedFaces (in ListOfGO theFacesOrShells, in boolean isIntersect);
    
    /*!
     *  \brief Replace coincident faces in \a theShapes by one face.
     *  \param theShapes Initial shapes.
     *  \param theTolerance Maximum distance between faces, which can be considered as coincident.
     *  \param doKeepNonSolids If FALSE, only solids will present in the result, otherwise all initial shapes.
     *  \return New GEOM_Object containing copies of theShapes without coincident faces.
     */
    GEOM_Object MakeGlueFaces (in ListOfGO theShapes, in double theTolerance, in boolean doKeepNonSolids);

    /*!
     *  Find coincident faces in theShapes for possible gluing.
     *  \param theShapes Initial shapes.
     *  \param theTolerance Maximum distance between faces, which can be considered as coincident.
     *  \return ListOfGO
     */
    ListOfGO GetGlueFaces (in ListOfGO theShapes, in double theTolerance);

    /*!
     *  \brief Replace coincident faces in \a theShapes by one face
     *         in compliance with given list of faces
     *  \param theShapes Initial shapes.
     *  \param theTolerance Maximum distance between faces, which can be considered as coincident.
     *  \param theFaces List of faces for gluing.
     *  \param doKeepNonSolids If FALSE, only solids will present in the result, otherwise all initial shapes.
     *  \param doGlueAllEdges If TRUE, all coincident edges of <VAR>theShape</VAR>
     *                        will be glued, otherwise only the edges,
     *                        belonging to <VAR>theFaces</VAR>.
     *  \return New GEOM_Object containing copies of theShapes without coincident faces.
     */
    GEOM_Object MakeGlueFacesByList (in ListOfGO theShapes, in double theTolerance,
                                     in ListOfGO theFaces,  in boolean doKeepNonSolids,
                                     in boolean doGlueAllEdges);

    /*!
     *  \brief Replace coincident edges in \a theShapes by one edge.
     *  \param theShapes Initial shapes.
     *  \param theTolerance Maximum distance between edges, which can be considered as coincident.
     *  \return New GEOM_Object containing copies of theShapes without coincident edges.
     */
    GEOM_Object MakeGlueEdges (in ListOfGO theShapes, in double theTolerance);

    /*!
     *  Find coincident edges in \a theShapes for possible gluing.
     *  \param theShapes Initial shapes.
     *  \param theTolerance Maximum distance between edges, which can be considered as coincident.
     *  \return ListOfGO
     */
    ListOfGO GetGlueEdges (in ListOfGO theShapes, in double theTolerance);

    /*!
     *  \brief Replace coincident edges in \a theShapes by one edge
     *         in compliance with given list of edges
     *  \param theShapes Initial shapes.
     *  \param theTolerance Maximum distance between edges, which can be considered as coincident.
     *  \param theEdges List of edges for gluing.
     *  \return New GEOM_Object containing copies of theShapes without some edges.
     */
    GEOM_Object MakeGlueEdgesByList (in ListOfGO theShapes,
                                     in double   theTolerance,
                                     in ListOfGO theEdges);

    /*!
     *  \brief Get all sub-shapes and groups of \a theShape,
     *  that were created already by any other methods.
     *  \param theShape Any shape.
     *  \param theGroupsOnly If this parameter is TRUE, only groups will be
     *                       returned, else all found sub-shapes and groups.
     *  \return List of existing sub-objects of \a theShape.
     */
    ListOfGO GetExistingSubObjects (in GEOM_Object theShape,
                                    in boolean     theGroupsOnly);

    /*!
     *  \brief Deprecated method. 
     *
     *  Use MakeAllSubShapes() instead.
     */
    ListOfGO MakeExplode (in GEOM_Object theShape,
                          in long        theShapeType,
                          in boolean     isSorted);

    /*!
     *  \brief Explode a shape on sub-shapes of a given type. 
     *
     *  If the shape itself has the given type, it is also returned.
     *  \param theShape Shape to be exploded.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param isSorted If this parameter is TRUE, sub-shapes will be
     *                  sorted by coordinates of their gravity centers.
     *  \return List of sub-shapes of type theShapeType, contained in theShape.
     */
    ListOfGO MakeAllSubShapes (in GEOM_Object theShape,
                               in long        theShapeType,
                               in boolean     isSorted);

    /*!
     *  \brief Extract all sub-shapes of the given type from
     *  the given shape, excluding the shape itself.
     *  \param theShape Shape to be exploded.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param isSorted If this parameter is TRUE, sub-shapes will be
     *                  sorted by coordinates of their gravity centers.
     *  \return List of sub-shapes of type theShapeType, contained in theShape.
     */
    ListOfGO ExtractSubShapes (in GEOM_Object theShape,
                               in long        theShapeType,
                               in boolean     isSorted);

    /*!
     *  \brief Deprecated method. Use GetAllSubShapesIDs() instead.
     */
    ListOfLong SubShapeAllIDs (in GEOM_Object theShape,
                               in long        theShapeType,
                               in boolean     isSorted);

    /*!
     *  \brief Explode a shape on sub-shapes of a given type.
     *
     *  Does the same, as MakeAllSubShapes, but returns IDs of
     *  sub-shapes, not GEOM_Object. It works faster.
     *  \param theShape Shape to be exploded.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param isSorted If this parameter is TRUE, sub-shapes will be
     *                  sorted by coordinates of their gravity centers.
     *  \return List of IDs of sub-shapes of type theShapeType, contained in theShape.
     */
    ListOfLong GetAllSubShapesIDs (in GEOM_Object theShape,
                                   in long        theShapeType,
                                   in boolean     isSorted);

    /*!
     *  \brief Get a sub-shape defined by its unique ID inside \a theMainShape
     *  \param theMainShape Main shape.
     *  \param theID Unique ID of sub-shape inside \a theMainShape.
     *  \return GEOM_Object, corresponding to found sub-shape.
     *  \note The sub-shape GEOM_Object can has ONLY ONE function.
     *        Don't try to apply modification operations (without copy) on them.
     */
    GEOM_Object GetSubShape (in GEOM_Object theMainShape,
                             in long        theID);

    /*!
     *  \brief Get a set of sub-shapes defined by their unique IDs inside \a theMainShape
     *  \param theMainShape Main shape.
     *  \param theIndices List of unique IDs of sub-shapes inside \a theMainShape.
     *  \return List of GEOM_Object, corresponding to found sub-shapes.
     *  \note The sub-shape GEOM_Object can has ONLY ONE function.
     *        Don't try to apply modification operations (without copy) on them.
     */
    ListOfGO MakeSubShapes (in GEOM_Object theMainShape,
                            in ListOfLong  theIndices);

    /*!
     *  Get global index of \a theSubShape in \a theMainShape.
     *  \param theMainShape Main shape.
     *  \param theSubShape Sub-shape of the main shape.
     *  \return global index of \a theSubShape in \a theMainShape.
     */
    long GetSubShapeIndex (in GEOM_Object theMainShape, in GEOM_Object theSubShape);

    /*!
     *  Get global indices of \a theSubShapes in \a theMainShape.
     *  \param theMainShape Main shape.
     *  \param theSubShapes List of sub-shapes of the main shape.
     *  \return list of global indices of \a theSubShapes in \a theMainShape.
     */
    ListOfLong GetSubShapesIndices (in GEOM_Object theMainShape, in ListOfGO theSubShapes);

    /*!
     *  \brief Get index of \a theSubShape in \a theMainShape, unique among sub-shapes of the same type.
     *
     *  Together with method <VAR>GetShapeTypeString()</VAR> it can be used
     *  to generate automatic names for sub-shapes, when publishing them in a study.
     *  \param theMainShape Main shape.
     *  \param theSubShape Sub-shape of the main shape.
     *  \return index of \a theSubShape in a list of all sub-shapes of \a theMainShape of the same type.
     */
    long GetTopologyIndex (in GEOM_Object theMainShape, in GEOM_Object theSubShape);

    /*!
     *  \brief Get name of type of \a theShape.
     *
     *  Use wide type notation, taking into consideration both topology and geometry of the shape.
     *  Together with method <VAR>GetTopologyIndex()</VAR> it can be used
     *  to generate automatic names for sub-shapes, when publishing them in a study.
     *  \param theShape The shape to get a type of.
     *  \return String, containing a type name of \a theShape.
     */
    string GetShapeTypeString (in GEOM_Object theShape);

    /*!
     *  \brief Check if the object is a sub-object of another GEOM object.
     *
     *  \param theSubObject Checked sub-object (or its parent object, in case if
     *                      \a theSubObjectIndex is non-zero).
     *  \param theSubObjectIndex When non-zero, specifies a sub-shape index that
     *                           identifies a sub-object within its parent specified via \a theSubObject.
     *  \param theObject An object that is checked for ownership (or its parent object,
     *                   in case if \a theObjectIndex is non-zero).
     *  \param theObjectIndex When non-zero, specifies a sub-shape index that
     *                        identifies an object within its parent specified via \a theObject.
     *  \return TRUE, if the given object contains sub-object.
     */
    boolean IsSubShapeBelongsTo( in GEOM_Object theSubObject,
                                 in long        theSubObjectIndex,
                                 in GEOM_Object theObject,
                                 in long        theObjectIndex);
    /*!
     *  \brief Count number of faces in the given shape.
     *  \param theShape Shape to count faces in.
     *  \return Number of faces in the given shape.
     */
    long NumberOfFaces (in GEOM_Object theShape);

    /*!
     *  \brief Count number of edges in the given shape.
     *  \param theShape Shape to count edges in.
     *  \return Number of edges in theShape.
     */
    long NumberOfEdges (in GEOM_Object theShape);

    /*!
     *  \brief Count number of sub-shapes of type \a theShapeType in the given shape.
     *  \param theShape Shape to count sub-shapes in.
     *  \param theShapeType The type of sub-shapes to count.
     *  \return Number of sub-shapes of type \a theShapeType in \a theShape.
     */
    long NumberOfSubShapes (in GEOM_Object theShape,
                            in long        theShapeType);

    /*!
     *  Reverses an orientation the given shape.
     *  \param theShape Shape to be reversed.
     *  \return The reversed copy of theShape.
     */
    GEOM_Object ChangeOrientation (in GEOM_Object theShape);

    /*!
     *  \brief Retrieve all free faces from the given shape.
     *
     *  Free face is a face, which is not shared between two shells of the shape.
     *  \param theShape Shape to find free faces in.
     *  \return List of IDs of all free faces, contained in theShape.
     */
    ListOfLong GetFreeFacesIDs (in GEOM_Object theShape);

    /*!
     *  \brief Get all sub-shapes of theShape1 of the given type, shared with theShape2.
     *  \param theShape1 Shape to find sub-shapes in.
     *  \param theShape2 Shape to find shared sub-shapes with.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \return List of sub-shapes of theShape1, shared with theShape2.
     */
    ListOfGO GetSharedShapes (in GEOM_Object theShape1,
                              in GEOM_Object theShape2,
                              in long        theShapeType);

    /*!
     *  \brief Get sub-shapes, shared by input shapes.
     *  \param theShapes Shapes to find common sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theMultiShare Specifies what type of shares should be checked:
     *         - \c TRUE: search sub-shapes from 1st input shape shared with all other input shapes;
     *         - \c FALSE: causes to search sub-shapes shared between couples of input shapes.
     *  \note If \a theShapes contains single compound, the shares between all possible couples of 
     *        its top-level shapes are returned; otherwise, only shares between 1st input shape
     *        and all rest input shapes are returned.
     *              
     *  \return List of all found sub-shapes.
     */
    ListOfGO GetSharedShapesMulti (in ListOfGO theShapes,
                                   in long     theShapeType,
				   in boolean  theMultiShare);

    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified plane by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theAx1 Vector (or line, or linear edge), specifying normal
     *                direction and location of the plane to find shapes on.
     *  \param theState The state of the sub-shapes to find.
     *  \return List of all found sub-shapes.
     */
    ListOfGO GetShapesOnPlane (in GEOM_Object theShape,
                               in long        theShapeType,
                               in GEOM_Object theAx1,
                               in shape_state theState);
    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified plane by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theAx1 Vector (or line, or linear edge), specifying normal
     *                direction of the plane to find shapes on.
     *  \param thePnt Point specifying location of the plane to find shapes on.
     *  \param theState The state of the sub-shapes to find.
     *  \return List of all found sub-shapes.
     */
    ListOfGO GetShapesOnPlaneWithLocation (in GEOM_Object theShape,
                                           in long        theShapeType,
                                           in GEOM_Object theAx1,
                                           in GEOM_Object thePnt,
                                           in shape_state theState);



    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified cylinder by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theAxis Vector (or line, or linear edge), specifying
     *                 axis of the cylinder to find shapes on.
     *  \param theRadius Radius of the cylinder to find shapes on.
     *  \param theState The state of the sub-shapes to find.
     *  \return List of all found sub-shapes.
     */
    ListOfGO GetShapesOnCylinder (in GEOM_Object theShape,
                                  in long        theShapeType,
                                  in GEOM_Object theAxis,
                                  in double      theRadius,
                                  in shape_state theState);

    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified cylinder by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theAxis Vector (or line, or linear edge), specifying
     *                 axis of the cylinder to find shapes on.
     *  \param thePnt Point specifying location of the bottom of the cylinder.
     *  \param theRadius Radius of the cylinder to find shapes on.
     *  \param theState The state of the sub-shapes to find.
     *  \return List of all found sub-shapes.
     */
    ListOfGO GetShapesOnCylinderWithLocation (in GEOM_Object theShape,
                                              in long        theShapeType,
                                              in GEOM_Object theAxis,
                                              in GEOM_Object thePnt,
                                              in double      theRadius,
                                              in shape_state theState);

    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified sphere by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theCenter Point, specifying center of the sphere to find shapes on.
     *  \param theRadius Radius of the sphere to find shapes on.
     *  \param theState The state of the sub-shapes to find.
     *  \return List of all found sub-shapes.
     */
    ListOfGO GetShapesOnSphere (in GEOM_Object theShape,
                                in long        theShapeType,
                                in GEOM_Object theCenter,
                                in double      theRadius,
                                in shape_state theState);

    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified quadrangle by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theTopLeftPoint Top left quadrangle corner
     *  \param theTopRightPoint Top right quadrangle corner
     *  \param theBottomLeftPoint Bottom left quadrangle corner
     *  \param theBottomRightPoint Bottom right quadrangle corner
     *  \param theState The state of the sub-shapes to find.
     *  \return List of all found sub-shapes.
     */
    ListOfGO GetShapesOnQuadrangle (in GEOM_Object theShape,
                                    in long        theShapeType,
                                    in GEOM_Object theTopLeftPoint,
                                    in GEOM_Object theTopRightPoint,
                                    in GEOM_Object theBottomLeftPoint,
                                    in GEOM_Object theBottomRightPoint,
                                    in shape_state theState);

    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified plane by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theAx1 Vector (or line, or linear edge), specifying normal
     *                direction and location of the plane to find shapes on.
     *  \param theState The state of the sub-shapes to find.
     *  \return List of IDs of all found sub-shapes.
     */
    ListOfLong GetShapesOnPlaneIDs (in GEOM_Object theShape,
                                    in long        theShapeType,
                                    in GEOM_Object theAx1,
                                    in shape_state theState);

    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified plane by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theAx1 Vector (or line, or linear edge), specifying normal
     *                direction of the plane to find shapes on.
     *  \param thePnt Point specifying location of the plane to find shapes on.
     *  \param theState The state of the sub-shapes to find.
     *  \return List of IDs of all found sub-shapes.
     */
    ListOfLong GetShapesOnPlaneWithLocationIDs (in GEOM_Object theShape,
                                                in long        theShapeType,
                                                in GEOM_Object theAx1,
                                                in GEOM_Object thePnt,
                                                in shape_state theState);

    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified cylinder by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theAxis Vector (or line, or linear edge), specifying
     *                 axis of the cylinder to find shapes on.
     *  \param theRadius Radius of the cylinder to find shapes on.
     *  \param theState The state of the sub-shapes to find.
     *  \return List of IDs of all found sub-shapes.
     */
    ListOfLong GetShapesOnCylinderIDs (in GEOM_Object theShape,
                                       in long        theShapeType,
                                       in GEOM_Object theAxis,
                                       in double      theRadius,
                                       in shape_state theState);

    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified cylinder by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theAxis Vector (or line, or linear edge), specifying
     *                 axis of the cylinder to find shapes on.
     *  \param thePnt Point specifying location of the bottom of the cylinder.
     *  \param theRadius Radius of the cylinder to find shapes on.
     *  \param theState The state of the sub-shapes to find.
     *  \return List of IDs all found sub-shapes.
     */
    ListOfLong GetShapesOnCylinderWithLocationIDs (in GEOM_Object theShape,
                                                   in long        theShapeType,
                                                   in GEOM_Object theAxis,
                                                   in GEOM_Object thePnt,
                                                   in double      theRadius,
                                                   in shape_state theState);

    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified sphere by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theCenter Point, specifying center of the sphere to find shapes on.
     *  \param theRadius Radius of the sphere to find shapes on.
     *  \param theState The state of the sub-shapes to find.
     *  \return List of IDs of all found sub-shapes.
     */
    ListOfLong GetShapesOnSphereIDs (in GEOM_Object theShape,
                                     in long        theShapeType,
                                     in GEOM_Object theCenter,
                                     in double      theRadius,
                                     in shape_state theState);

    /*!
     *  \brief Find in \a theShape all sub-shapes of type \a theShapeType, situated relatively
     *  the specified quadrangle by the certain way, defined through \a theState parameter.
     *  \param theShape Shape to find sub-shapes of.
     *  \param theShapeType Type of sub-shapes to be retrieved.
     *  \param theTopLeftPoint Top left quadrangle corner
     *  \param theTopRightPoint Top right quadrangle corner
     *  \param theBottomLeftPoint Bottom left quadrangle corner
     *  \param theBottomRightPoint Bottom right quadrangle corner
     *  \param theState The state of the sub-shapes to find.
     *  \return List of IDs of all found sub-shapes.
     */
    ListOfLong GetShapesOnQuadrangleIDs (in GEOM_Object theShape,
                                         in long        theShapeType,
                                         in GEOM_Object theTopLeftPoint,
                                         in GEOM_Object theTopRightPoint,
                                         in GEOM_Object theBottomLeftPoint,
                                         in GEOM_Object theBottomRightPoint,
                                         in shape_state theState);

    /*!
     * \brief Find sub-shapes complying with given status
     * \param theBox - the box to check state of sub-shapes against
     * \param theShape - the shape to explore
     * \param theShapeType - type of sub-shape of theShape
     * \param theState - required state
     * \return List of IDs of all found sub-shapes.
     */
    ListOfLong GetShapesOnBoxIDs (in GEOM_Object theBox,
                                  in GEOM_Object theShape,
                                  in long        theShapeType,
                                  in shape_state theState);

    /*!
     * \brief Find sub-shapes complying with given status
     * \param theBox - the box to check state of sub-shapes against
     * \param theShape - the shape to explore
     * \param theShapeType - type of sub-shape of theShape
     * \param theState - required state
     * \return List of all found sub-shapes.
     */
    ListOfGO GetShapesOnBox (in GEOM_Object theBox,
                             in GEOM_Object theShape,
                             in long        theShapeType,
                             in shape_state theState);

    /*!
     * \brief Find sub-shapes complying with given status
     * \param theCheckShape - the shape to check state of sub-shapes against. It must be a solid.
     * \param theShape - the shape to explore
     * \param theShapeType - type of sub-shape of theShape
     * \param theState - required state
     * \return List of IDs of all found sub-shapes.
     */
    ListOfLong GetShapesOnShapeIDs (in GEOM_Object theCheckShape,
                                    in GEOM_Object theShape,
                                    in short       theShapeType,
                                    in shape_state theState);

    /*!
     * \brief Find sub-shapes complying with given status
     * \param theCheckShape - the shape to check state of sub-shapes against. It must be a solid.
     * \param theShape - the shape to explore
     * \param theShapeType - type of sub-shape of theShape
     * \param theState - required state
     * \return List of all found sub-shapes.
     */
    ListOfGO GetShapesOnShape (in GEOM_Object theCheckShape,
                               in GEOM_Object theShape,
                               in short       theShapeType,
                               in shape_state theState);

    /*!
     * \brief Find sub-shapes complying with given status
     * \param theCheckShape - the shape to check state of sub-shapes against. It must be a solid.
     * \param theShape - the shape to explore
     * \param theShapeType - type of sub-shape of theShape
     * \param theState - required state
     * \return compound includes all found sub-shapes.
     */
    GEOM_Object GetShapesOnShapeAsCompound (in GEOM_Object theCheckShape,
                                            in GEOM_Object theShape,
                                            in short       theShapeType,
                                            in shape_state theState);

    /*!
     *  \brief Get sub-shape(s) of \a theShapeWhere, which are
     *  coincident with \a theShapeWhat or could be a part of it.
     *  \param theShapeWhere Shape to find sub-shapes of.
     *  \param theShapeWhat Shape, specifying what to find.
     *  \return Compound which includes all found sub-shapes if they have different types; 
     *          or group of all found shapes of the equal type; or a single found sub-shape.
     */
    GEOM_Object GetInPlace (in GEOM_Object theShapeWhere,
                            in GEOM_Object theShapeWhat);

    /*!
     *  Old implementation of GetInPlace functionality, based on shape properties.
     */
    GEOM_Object GetInPlaceOld (in GEOM_Object theShapeWhere,
                               in GEOM_Object theShapeWhat);

    /*!
     *  \brief Get sub-shape(s) of \a theShapeWhere, which are
     *  coincident with \a theShapeWhat or could be a part of it.
     *
     *  Implementation of this method is based on a saved history of an operation,
     *  produced \a theShapeWhere. The \a theShapeWhat must be among this operation's
     *  arguments (an argument shape or a sub-shape of an argument shape).
     *  The operation could be the Partition or one of boolean operations,
     *  performed on simple shapes (not on compounds).
     *
     *  \param theShapeWhere Shape to find sub-shapes of.
     *  \param theShapeWhat Shape, specifying what to find.
     *  \return Compound which includes all found sub-shapes if they have different types; 
     *          or group of all found shapes of the equal type; or a single found sub-shape.
     */
    GEOM_Object GetInPlaceByHistory (in GEOM_Object theShapeWhere,
                                     in GEOM_Object theShapeWhat);

    /*!
     *  \brief A sort of GetInPlace functionality, returning for each sub-shape ID of 
     *  \a theShapeWhat a list of corresponding sub-shape IDs of \a theShapeWhere.
     *  For example, if theShapeWhat is a box and theShapeWhere is this box cut into 
     *  two parts by a plane, then the result can be as this: 
     *    len( result_list ) = 35,
     *    result_list[ 1 ] = [ 2, 36 ], which means that the box turned into two solids
     *  with IDs 2 and 36 within theShapeWhere
     */
    ListOfListOfLong GetInPlaceMap (in GEOM_Object theShapeWhere,
                                    in GEOM_Object theShapeWhat);

    /*!
     *  \brief Get sub-shape of theShapeWhere, which are
     *  coincident with \a theShapeWhat that can either SOLID, FACE, EDGE or VERTEX.
     *  \param theShapeWhere Shape to find sub-shapes of.
     *  \param theShapeWhat Shape, specifying what to find.
     *  \return found sub-shape.
     */
    GEOM_Object GetSame (in GEOM_Object theShapeWhere,
                         in GEOM_Object theShapeWhat);

    /*!
     *  \brief Get sub-shape Ids of theShapeWhere, which are
     *   coincident with \a theShapeWhat that can either SOLID, FACE, EDGE or VERTEX.
     *  \param theShapeWhere Shape to find sub-shapes of.
     *  \param theShapeWhat Shape, specifying what to find.
     *  \return found sub-shape Ids.
     */
    ListOfLong GetSameIDs (in GEOM_Object theShapeWhere,
                           in GEOM_Object theShapeWhat);

    /*!
     *  \brief Resize the input edge with the new Min and Max parameters.
     *  The input edge parameters range is [0, 1]. If theMin parameter is
     *  negative, the input edge is extended, otherwise it is shrinked by
     *  theMin parameter. If theMax is greater than 1, the edge is extended,
     *  otherwise it is shrinked by theMax parameter.
     *  \param theEdge the input edge to be resized.
     *  \param theMin the minimal parameter value.
     *  \param theMax the maximal parameter value.
     *  \return a newly created edge.
     */
    GEOM_Object ExtendEdge(in GEOM_Object theEdge,
                           in double      theMin,
                           in double      theMax);

    /*!
     *  \brief Resize the input face with the new UMin, UMax, VMin and VMax
     *  parameters. The input face U and V parameters range is [0, 1]. If
     *  theUMin parameter is negative, the input face is extended, otherwise
     *  it is shrinked along U direction by theUMin parameter. If theUMax is
     *  greater than 1, the face is extended, otherwise it is shrinked along
     *  U direction by theUMax parameter. So as for theVMin, theVMax and
     *  V direction of the input face.
     *  \param theFace the input face to be resized.
     *  \param theUMin the minimal U parameter value.
     *  \param theUMax the maximal U parameter value.
     *  \param theVMin the minimal V parameter value.
     *  \param theVMax the maximal V parameter value.
     *  \return a newly created face.
     */
    GEOM_Object ExtendFace(in GEOM_Object theFace,
                           in double      theUMin,
                           in double      theUMax,
                           in double      theVMin,
                           in double      theVMax);

    /*!
     *  \brief Make a surface from a face. This function takes some face as
     *  input parameter and creates new GEOM_Object, i.e. topological shape
     *  by extracting underlying surface of the source face and limiting it
     *  by the Umin, Umax, Vmin, Vmax parameters of the source face (in the
     *  parametrical space).
     *  \param theFace the input face.
     *  \return a newly created face.
     */
    GEOM_Object MakeSurfaceFromFace(in GEOM_Object theFace);

    /*!
     * \brief Explode a shape into edges sorted in a row from a starting point.
     * \param theShape - the shape to be exploded on edges.
     * \param theStartPoint - the starting point.
     * \return Ordered list of edges sorted in a row from a starting point.
     */
    ListOfGO GetSubShapeEdgeSorted (in GEOM_Object theShape,
                                    in GEOM_Object theStartPoint);

    /*!
     * \brief Return the list of subshapes that satisfies a certain tolerance
     * criterion. The user defines the type of shapes to be returned, the
     * condition and the tolerance value. The operation is defined for
     * faces, edges and vertices only. E.g. for theShapeType FACE, theCondition
     * CC_GT and theTolerance 1.e-7 this method returns all faces of theShape
     * that have tolerances greater then 1.e7.
     *
     * \param theShape the shape to be exploded
     * \param theShapeType the type of shapes to be returned. Can have the
     *        values FACE, EDGE and VERTEX only.
     * \param theCondition the condition type.
     * \param theTolerance the tolerance filter.
     * \return the list of shapes that satisfy the conditions.
     */
    ListOfGO GetSubShapesWithTolerance(in GEOM_Object          theShape,
                                       in short                theShapeType,
                                       in comparison_condition theCondition,
                                       in double               theTolerance);

    /**
     * This enumeration represents an extraction statistics type. It is used in
     * the interface GEOM_IShapesOperations::MakeExtraction.
     */
    enum ExtractionStatType
    {
      EST_Removed,  ///< Removed sub-shapes
      EST_Modified, ///< Modified sub-shapes
      EST_Added     ///< Newly created sub-shapes
    };

    /*!
     * This structure defines a format of extraction statistics. It is used in
     * the interface GEOM_IShapesOperations::MakeExtraction.
     */
    struct ExtractionStat
    {
      ExtractionStatType type;    ///< Type of extraction statistics.
      ListOfLong         indices; ///< Shape indices touched by this type of modification.
    };

    typedef sequence<ExtractionStat> ExtractionStats;

    /*!
     * \brief Return the shape that is constructed from theShape without
     * extracted sub-shapes from the input list.
     *
     * \param theShape the original shape.
     * \param theSubShapeIDs the list of sub-shape IDs to be extracted from
     *        the original shape.
     * \param theStats the operation statistics. Output parameter.
     * \return the shape without extracted sub-shapes.
     */
    GEOM_Object MakeExtraction(in GEOM_Object      theShape,
                               in ListOfLong       theSubShapeIDs,
                               out ExtractionStats theStats);

  };

 // # GEOM_IBlocksOperations: 
  /*!
   *  \brief Interface for Blocks construction
   *  Face from points or edges, Block from faces,
   *  Blocks multi-translation and multi-rotation
   */
  interface GEOM_IBlocksOperations : GEOM_IOperations
  {
   
  //  # Creation of blocks

    /*!
     *  \brief Create a quadrangle face from four edges. Order of Edges is not
     *  important. It is not necessary that edges share the same vertex.
     *  \param theEdge1,theEdge2,theEdge3,theEdge4 Edges for the face bound.
     *  \return New GEOM_Object, containing the created face.
     */
    GEOM_Object MakeQuad (in GEOM_Object theEdge1,
                          in GEOM_Object theEdge2,
                          in GEOM_Object theEdge3,
                          in GEOM_Object theEdge4);

    /*!
     *  \brief Create a quadrangle face on two edges.
     *
     *  The missing edges will be built by creating the shortest ones.
     *  \param theEdge1,theEdge2 Two opposite edges for the face.
     *  \return New GEOM_Object, containing the created face.
     */
    GEOM_Object MakeQuad2Edges (in GEOM_Object theEdge1,
                                in GEOM_Object theEdge2);

    /*!
     *  \brief Create a quadrangle face with specified corners.
     *
     *  The missing edges will be built by creating the shortest ones.
     *  \param thePnt1,thePnt2,thePnt3,thePnt4 Corner vertices for the face.
     *  \return New GEOM_Object, containing the created face.
     */
    GEOM_Object MakeQuad4Vertices (in GEOM_Object thePnt1,
                                   in GEOM_Object thePnt2,
                                   in GEOM_Object thePnt3,
                                   in GEOM_Object thePnt4);

    /*!
     *  \brief Create a hexahedral solid, bounded by the six given faces. Order of
     *  faces is not important. 
     *
     *  It is not necessary that Faces share the same edge.
     *  \param theFace1,theFace2,theFace3,theFace4,theFace5,theFace6 Faces for the hexahedral solid.
     *  \return New GEOM_Object, containing the created solid.
     */
    GEOM_Object MakeHexa (in GEOM_Object theFace1,
                          in GEOM_Object theFace2,
                          in GEOM_Object theFace3,
                          in GEOM_Object theFace4,
                          in GEOM_Object theFace5,
                          in GEOM_Object theFace6);

    /*!
     *  \brief Create a hexahedral solid between two given faces.
     *
     *  The missing faces will be built by creating the smallest ones.
     *  \param theFace1,theFace2 Two opposite faces for the hexahedral solid.
     *  \return New GEOM_Object, containing the created solid.
     */
    GEOM_Object MakeHexa2Faces (in GEOM_Object theFace1,
                                in GEOM_Object theFace2);

    
  //  # Extract elements of blocks and blocks compounds
     

    /*!
     *  \brief Get a vertex, found in the given shape by its coordinates.
     *  \param theShape Block or a compound of blocks.
     *  \param theX,theY,theZ Coordinates of the sought vertex.
     *  \param theEpsilon Maximum allowed distance between the resulting
     *                    vertex and point with the given coordinates.
     *  \return New GEOM_Object, containing the found vertex.
     */
    GEOM_Object GetPoint (in GEOM_Object theShape,
                          in double      theX,
                          in double      theY,
                          in double      theZ,
                          in double      theEpsilon);

    /*!
     *  \brief Find a vertex of the given shape, which has minimal distance to the given point.
     *  \param theShape Any shape.
     *  \param thePoint Point, close to the desired vertex.
     *  \return New GEOM_Object, containing the found vertex.
     */
    GEOM_Object GetVertexNearPoint (in GEOM_Object theShape,
                                    in GEOM_Object thePoint);

    /*!
     *  \brief Get an edge, found in the given shape by two given vertices.
     *  \param theShape Block or a compound of blocks.
     *  \param thePoint1,thePoint2 Points, close to the ends of the desired edge.
     *  \return New GEOM_Object, containing the found edge.
     */
    GEOM_Object GetEdge (in GEOM_Object theShape,
                         in GEOM_Object thePoint1,
                         in GEOM_Object thePoint2);

    /*!
     *  \brief Find an edge of the given shape, which has minimal distance to the given point.
     *  \param theShape Block or a compound of blocks.
     *  \param thePoint Point, close to the desired edge.
     *  \return New GEOM_Object, containing the found edge.
     */
    GEOM_Object GetEdgeNearPoint (in GEOM_Object theShape,
                                  in GEOM_Object thePoint);

    /*!
     *  \brief Returns a face, found in the given shape by four given corner vertices.
     *  \param theShape Block or a compound of blocks.
     *  \param thePoint1,thePoint2,thePoint3,thePoint4 Points, close to the corners of the desired face.
     *  \return New GEOM_Object, containing the found face.
     */
    GEOM_Object GetFaceByPoints (in GEOM_Object theShape,
                                 in GEOM_Object thePoint1,
                                 in GEOM_Object thePoint2,
                                 in GEOM_Object thePoint3,
                                 in GEOM_Object thePoint4);

    /*!
     *  \brief Get a face of block, found in the given shape by two given edges.
     *  \param theShape Block or a compound of blocks.
     *  \param theEdge1,theEdge2 Edges, close to the edges of the desired face.
     *  \return New GEOM_Object, containing the found face.
     */
    GEOM_Object GetFaceByEdges (in GEOM_Object theShape,
                                in GEOM_Object theEdge1,
                                in GEOM_Object theEdge2);

    /*!
     *  \brief Find a face, opposite to the given one in the given block.
     *  \param theBlock Must be a hexahedral solid.
     *  \param theFace Face of \a theBlock, opposite to the desired face.
     *  \return New GEOM_Object, containing the found face.
     */
    GEOM_Object GetOppositeFace (in GEOM_Object theBlock,
                                 in GEOM_Object theFace);

    /*!
     *  \brief Find a face of the given shape, which has minimal distance to the given point.
     *  \param theShape Block or a compound of blocks.
     *  \param thePoint Point, close to the desired face.
     *  \return New GEOM_Object, containing the found face.
     */
    GEOM_Object GetFaceNearPoint (in GEOM_Object theShape,
                                  in GEOM_Object thePoint);

    /*!
     *  \brief Find a face of block, whose outside normale has minimal angle with the given vector.
     *  \param theBlock Block or a compound of blocks.
     *  \param theVector Vector, close to the normale of the desired face.
     *  \return New GEOM_Object, containing the found face.
     */
    GEOM_Object GetFaceByNormale (in GEOM_Object theBlock,
                                  in GEOM_Object theVector);

    /*!
     *  \brief Find all sub-shapes of type \a theShapeType of the given shape,
     *  which have minimal distance to the given point.
     *  \param theShape Any shape.
     *  \param thePoint Point, close to the desired shape.
     *  \param theShapeType Defines what kind of sub-shapes is searched.
     *  \param theTolerance The tolerance for distances comparison. All shapes
     *                      with distances to the given point in interval
     *                      [minimal_distance, minimal_distance + theTolerance] will be gathered.
     *  \return New GEOM_Object, containing a group of all found shapes.
     */
    GEOM_Object GetShapesNearPoint (in GEOM_Object theShape,
                                    in GEOM_Object thePoint,
                                    in long        theShapeType,
                                    in double      theTolerance);

   //  #  Extract blocks from blocks compounds
     

    /*!
     *  \brief Check, if the compound contains only specified blocks.
     *  \param theCompound The compound to check.
     *  \param theMinNbFaces If solid has lower number of faces, it is not a block.
     *  \param theMaxNbFaces If solid has higher number of faces, it is not a block.
     *    \note If theMaxNbFaces = 0, the maximum number of faces is not restricted.
     *  \param theNbBlocks Number of specified blocks in theCompound.
     *  \return TRUE, if the given compound contains only blocks.
     */
    boolean IsCompoundOfBlocks (in GEOM_Object theCompound,
                                in long        theMinNbFaces,
                                in long        theMaxNbFaces,
                                out long       theNbBlocks);

    /*!
     *  \brief Enumeration of Blocks Compound defects.
     */
    enum BCErrorType
    {
      /* Each element of the compound should be a Block */
      NOT_BLOCK,

      /* An element is a potential block, but has degenerated and/or seam edge(s). */
      EXTRA_EDGE,

      /* A connection between two Blocks should be an entire face or an entire edge */
      INVALID_CONNECTION,

      /* The compound should be connexe */
      NOT_CONNECTED,

      /* The glue between two quadrangle faces should be applied */
      NOT_GLUED
    };

    /*!
     *  \brief Description of Blocks Compound defect: type and incriminated sub-shapes.
     */
    struct BCError
    {
      BCErrorType error;
      ListOfLong  incriminated;
    };

    /*!
     *  \brief Sequence of all Blocks Compound defects.
     */
    typedef sequence<BCError> BCErrors;

    /*!
     *  \brief Check, if the compound of blocks is given.
     *
     *  To be considered as a compound of blocks, the
     *  given shape must satisfy the following conditions:
     *  - Each element of the compound should be a Block (6 faces and 12 edges).
     *  - A connection between two Blocks should be an entire quadrangle face or an entire edge.
     *  - The compound should be connexe.
     *  - The glue between two quadrangle faces should be applied.
     *    \note Single block is also accepted as a valid compound of blocks.
     *  \param theCompound The compound to check.
     *  \param theToleranceC1 the tolerance to check if two neighbor edges are
     *         collinear in the common vertex with this tolerance. Negative
     *         value means that C1 criterion is not used (old implementation).
     *  \param theErrors Structure, containing discovered errors and incriminated sub-shapes.
     *  \return TRUE, if the given shape is a compound of blocks.
     */
    boolean CheckCompoundOfBlocks (in GEOM_Object theCompound,
                                   in double      theToleranceC1,
                                   out BCErrors   theErrors);

    /*!
     *  \brief Convert sequence of Blocks Compound errors, returned by
     *  <VAR>CheckCompoundOfBlocks()</VAR>, into string.
     *  \param theCompound The bad compound.
     *  \param theErrors The sequence of \a theCompound errors.
     *  \return String, describing all the errors in form, suitable for printing.
     */
    string PrintBCErrors (in GEOM_Object theCompound,
                          in BCErrors    theErrors);

    /*!
     *  \brief Retrieve all non blocks solids and faces from a shape.
     *
     *  \param theShape The shape to explore.
     *  \param theToleranceC1 the tolerance to check if two neighbor edges are
     *         collinear in the common vertex with this tolerance. Negative
     *         value means that C1 criterion is not used (old implementation).
     *  \param theNonQuads Output parameter. Group of all non quadrangular faces.
     *
     *  \return Group of all non block solids (= not 6 faces, or with 6
     *          faces, but with the presence of non-quadrangular faces).
     */
    GEOM_Object GetNonBlocks (in GEOM_Object  theShape,
                              in double       theToleranceC1,
                              out GEOM_Object theNonQuads);

    /*!
     *  \brief Remove all seam and degenerated edges from \a theShape.
     *
     *  Unite faces and edges, sharing one surface.
     *  \param theShape The compound or single solid to remove irregular edges from.
     *  \param theOptimumNbFaces If more than zero, unite faces only for those solids,
     *         that have more than theOptimumNbFaces faces. If zero, unite faces always,
     *         regardsless their quantity in the solid. If negative, do not unite faces at all.
     *         For blocks repairing recommended value is 6.
     *  \return Improved shape.
     */
    GEOM_Object RemoveExtraEdges (in GEOM_Object theShape,
                                  in long        theOptimumNbFaces);

    /*!
     *  \brief Performs union faces of \a theShape.
     *
     *  Unite faces sharing one surface.
     *  \param theShape The compound or single solid that contains faces to perform union.
     *  \return Improved shape.
     */
    GEOM_Object UnionFaces (in GEOM_Object theShape);

    /*!
     *  \brief Check, if the given shape is a blocks compound.
     *
     *  Fix all detected errors.
     *    \note Single block can be also fixed by this method.
     *  \param theCompound The compound to check and improve.
     *  \return Improved compound.
     */
    GEOM_Object CheckAndImprove (in GEOM_Object theCompound);

    /*!
     *  \brief Get all the blocks, contained in the given compound.
     *
     *  \param theCompound The compound to explode.
     *  \param theMinNbFaces If solid has lower number of faces, it is not a block.
     *  \param theMaxNbFaces If solid has higher number of faces, it is not a block.
     *    \note If theMaxNbFaces = 0, the maximum number of faces is not restricted.
     *  \return List of GEOM_Object, containing the retrieved blocks.
     */
    ListOfGO ExplodeCompoundOfBlocks (in GEOM_Object theCompound,
                                      in long        theMinNbFaces,
                                      in long        theMaxNbFaces);

    /*!
     *  \brief Find block, containing the given point inside its volume or on boundary.
     *  \param theCompound Compound, to find block in.
     *  \param thePoint Point, close to the desired block. If the point lays on
     *         boundary between some blocks, we return block with nearest center.
     *  \return New GEOM_Object, containing the found block.
     */
    GEOM_Object GetBlockNearPoint (in GEOM_Object theCompound,
                                   in GEOM_Object thePoint);

    /*!
     *  \brief Find block, containing all the elements, passed as the parts, or maximum quantity of them.
     *  \param theCompound Compound, to find block in.
     *  \param theParts List of faces and/or edges and/or vertices to be parts of the found block.
     *  \return New GEOM_Object, containing the found block.
     */
    GEOM_Object GetBlockByParts (in GEOM_Object theCompound,
                                 in ListOfGO    theParts);

    /*!
     *  \brief Return all blocks, containing all the elements, passed as the parts.
     *  \param theCompound Compound, to find blocks in.
     *  \param theParts List of faces and/or edges and/or vertices to be parts of the found blocks.
     *  \return List of GEOM_Object, containing the found blocks.
     */
    ListOfGO GetBlocksByParts (in GEOM_Object theCompound,
                               in ListOfGO    theParts);

  // #  Operations on blocks with gluing of result

    /*!
     *  \brief Multi-transformate block and glue the result.
     *
     *  Transformation is defined so, as to superpose theDirFace1 with theDirFace2.
     *  \param theBlock Hexahedral solid to be multi-transformed.
     *  \param theDirFace1 First direction face global index.
     *  \param theDirFace2 Second direction face global index.
     *  \param theNbTimes Quantity of transformations to be done.
     *    \note Global index of sub-shape can be obtained, using method
     *          <VAR>GEOM_IShapesOperations.GetSubShapeIndex()</VAR>.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeMultiTransformation1D (in GEOM_Object theBlock,
                                           in long        theDirFace1,
                                           in long        theDirFace2,
                                           in long        theNbTimes);

    /*!
     *  \brief Multi-transformate block and glue the result.
     *  \param theBlock Hexahedral solid to be multi-transformed.
     *  \param theDirFace1U,theDirFace2U Direction faces for the first transformation.
     *  \param theDirFace1V,theDirFace2V Direction faces for the second transformation.
     *  \param theNbTimesU,theNbTimesV Quantity of transformations to be done.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeMultiTransformation2D (in GEOM_Object theBlock,
                                           in long        theDirFace1U,
                                           in long        theDirFace2U,
                                           in long        theNbTimesU,
                                           in long        theDirFace1V,
                                           in long        theDirFace2V,
                                           in long        theNbTimesV);

  // # Special operation - propagation
   

    /*!
     *  \brief Build all possible propagation groups.
     *
     *  Propagation group is a set of all edges, opposite to one (main)
     *  edge of this group directly or through other opposite edges.
     *  Notion of Opposite Edge make sense only on quadrangle face.
     *  \param theShape Shape to build propagation groups on.
     *  \return List of GEOM_Object, each of them is a propagation group.
     */
    ListOfGO Propagate (in GEOM_Object theShape);
  };

 // # GEOM_IBooleanOperations
  /*!
   *  \brief Interface for boolean operations (Cut, Fuse, Common)
   */
  interface GEOM_IBooleanOperations : GEOM_IOperations
  {
    /*!
     *  \brief Perform one of boolean operations on two given shapes.
     *  \param theShape1 First argument for boolean operation.
     *  \param theShape2 Second argument for boolean operation.
     *  \param theOperation Indicates the operation to be done:
     *                      1 - Common, 2 - Cut, 3 - Fuse, 4 - Section.
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeBoolean (in GEOM_Object theShape1,
                             in GEOM_Object theShape2,
                             in long        theOperation,
                             in boolean     IsCheckSelfInte);
    /*!
     *  \brief Perform fusion boolean operation on two given shapes.
     *  \param theShape1 First argument for fuse operation.
     *  \param theShape2 Second argument for fuse operation.
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \param IsRmExtraEdges If TRUE, perform removal of extra edges
     *                        during an operation.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeFuse (in GEOM_Object theShape1,
                          in GEOM_Object theShape2,
                          in boolean     IsCheckSelfInte,
                          in boolean     IsRmExtraEdges);

    /*!
     *  \brief Perform fusion boolean operation on list of objects.
     *  \param theShapes Shapes to be fused.
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \param IsRmExtraEdges If TRUE, perform removal of extra edges
     *                        during an operation.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeFuseList (in ListOfGO theShapes,
                              in boolean  IsCheckSelfInte,
                              in boolean  IsRmExtraEdges);

    /*!
     *  \brief Perform common boolean operation on list of objects.
     *  \param theShapes Shapes for common operation.
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeCommonList (in ListOfGO theShapes,
                                in boolean  IsCheckSelfInte);

    /*!
     *  \brief Perform cutting of list of objects from theMainShape.
     *  \param theMainShape the object for cut operation.
     *  \param theShapes Shapes to be cut from theMainShape (tools).
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeCutList (in GEOM_Object theMainShape,
                             in ListOfGO theShapes,
                             in boolean  IsCheckSelfInte);

    /*!
     *  \brief Perform partition operation.
     *
     *  \param theShapes Shapes to be intersected.
     *  \param theTools Shapes to intersect theShapes.
     *  \note  Each compound from ListShapes and ListTools will be exploded in order
     *         to avoid possible intersection between shapes from this compound.
     *  \param theLimit Type of resulting shapes (corresponding to TopAbs_ShapeEnum).
     *  \param theKeepNonlimitShapes: if this parameter == 0, then only shapes of
     *                             target type (equal to Limit) are kept in the result,
     *                             else standalone shapes of lower dimension
     *                             are kept also (if they exist).
     *
     *  After implementation new version of PartitionAlgo (October 2006)
     *  other parameters are ignored by current functionality. They are kept
     *  in this function only for supporting old versions.
     *  Ignored parameters:
     *  \param theKeepInside Shapes, outside which the results will be deleted.
     *         Each shape from theKeepInside must belong to theShapes also.
     *  \param theRemoveInside Shapes, inside which the results will be deleted.
     *         Each shape from theRemoveInside must belong to theShapes also.
     *  \param theRemoveWebs If TRUE, perform Glue 3D algorithm.
     *  \param theMaterials Material indices for each shape. Make sense, only if theRemoveWebs is TRUE.
     *
     *  \return New GEOM_Object, containing the result shapes.
     */
    GEOM_Object MakePartition (in ListOfGO   theShapes,
                               in ListOfGO   theTools,
                               in ListOfGO   theKeepInside,
                               in ListOfGO   theRemoveInside,
                               in short      theLimit,
                               in boolean    theRemoveWebs,
                               in ListOfLong theMaterials,
                               in short      theKeepNonlimitShapes);

    /*!
     *  \brief Perform partition operation.
     *
     *  This method may be useful if it is needed to make a partition for
     *  a compound containing nonintersected shapes. Performance will be better
     *  since intersection between shapes from compound is not performed.
     *
     *  Description of all parameters as in previous method MakePartition().
     *  One additional parameter is provided:
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *
     *  \note Passed compounds (via ListShapes or via ListTools)
     *        have to consist of nonintersecting shapes.
     *
     *  \return New GEOM_Object, containing the result shapes.
     */
    GEOM_Object MakePartitionNonSelfIntersectedShape (in ListOfGO   theShapes,
                                                      in ListOfGO   theTools,
                                                      in ListOfGO   theKeepInside,
                                                      in ListOfGO   theRemoveInside,
                                                      in short      theLimit,
                                                      in boolean    theRemoveWebs,
                                                      in ListOfLong theMaterials,
                                                      in short      theKeepNonlimitShapes,
                                                      in boolean    IsCheckSelfInte);

    /*!
     *  \brief Perform partition of the Shape with the Plane
     *  \param theShape Shape to be intersected.
     *  \param thePlane Tool shape, to intersect theShape.
     *  \return New GEOM_Object, containing the result shape.
     * 
     *  \note This operation is a shortcut to the more general \ref MakePartition
     *  operation, where \a theShape specifies single "object" (shape being partitioned)
     *  and \a thePlane specifies single "tool" (intersector shape). Other parameters of
     *  \ref MakePartition operation have default values:
     *  - \a theLimit: GEOM::SHAPE (shape limit corresponds to the type of \a theShape)
     *  - \a theKeepNonlimitShapes: 0
     *  - \a theKeepInside, \a theRemoveInside, \a theRemoveWebs,
     *    \a theMaterials (obsolete parameters): empty
     *
     * \sa MakePartition, MakePartitionNonSelfIntersectedShape
     */
    GEOM_Object MakeHalfPartition (in GEOM_Object theShape,
                                   in GEOM_Object thePlane);

    /*!
     * [bos#40619] [CEA] Add Fuzzy parameter to partition and boolean operators
     * New interface methods were added to support a fuzzy parameter in
     * all boolean and partition operations:
     *  - MakeBooleanWithFuzzy
     *  - MakeFuseWithFuzzy
     *  - MakeFuseListWithFuzzy
     *  - MakeCommonListWithFuzzy
     *  - MakeCutListWithFuzzy
     *  - MakePartitionWithFuzzy
     *  - MakePartitionNonSelfIntersectedShapeWithFuzzy
     *  - MakeHalfPartitionWithFuzzy
     */

      /*!
     *  \brief Perform one of boolean operations on two given shapes.
     *  \param theShape1 First argument for boolean operation.
     *  \param theShape2 Second argument for boolean operation.
     *  \param theOperation Indicates the operation to be done:
     *                      1 - Common, 2 - Cut, 3 - Fuse, 4 - Section.
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \param theFuzzyParam The fuzzy tolerance to be used in the boolean
     *                       algorithm, if the value is positive.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeBooleanWithFuzzy (in GEOM_Object theShape1,
                                      in GEOM_Object theShape2,
                                      in long        theOperation,
                                      in boolean     IsCheckSelfInte,
                                      in double      theFuzzyParam);
    /*!
     *  \brief Perform fusion boolean operation on two given shapes.
     *  \param theShape1 First argument for fuse operation.
     *  \param theShape2 Second argument for fuse operation.
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \param IsRmExtraEdges If TRUE, perform removal of extra edges
     *                        during an operation.
     *  \param theFuzzyParam The fuzzy tolerance to be used in the boolean
     *                       algorithm, if the value is positive.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeFuseWithFuzzy (in GEOM_Object theShape1,
                                   in GEOM_Object theShape2,
                                   in boolean     IsCheckSelfInte,
                                   in boolean     IsRmExtraEdges,
                                   in double      theFuzzyParam);

    /*!
     *  \brief Perform fusion boolean operation on list of objects.
     *  \param theShapes Shapes to be fused.
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \param IsRmExtraEdges If TRUE, perform removal of extra edges
     *                        during an operation.
     *  \param theFuzzyParam The fuzzy tolerance to be used in the boolean
     *                       algorithm, if the value is positive.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeFuseListWithFuzzy (in ListOfGO theShapes,
                                       in boolean  IsCheckSelfInte,
                                       in boolean  IsRmExtraEdges,
                                       in double   theFuzzyParam);

    /*!
     *  \brief Perform common boolean operation on list of objects.
     *  \param theShapes Shapes for common operation.
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \param theFuzzyParam The fuzzy tolerance to be used in the boolean
     *                       algorithm, if the value is positive.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeCommonListWithFuzzy (in ListOfGO theShapes,
                                         in boolean  IsCheckSelfInte,
                                         in double   theFuzzyParam);

    /*!
     *  \brief Perform cutting of list of objects from theMainShape.
     *  \param theMainShape the object for cut operation.
     *  \param theShapes Shapes to be cut from theMainShape (tools).
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \param theFuzzyParam The fuzzy tolerance to be used in the boolean
     *                       algorithm, if the value is positive.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeCutListWithFuzzy (in GEOM_Object theMainShape,
                                      in ListOfGO    theShapes,
                                      in boolean     IsCheckSelfInte,
                                      in double      theFuzzyParam);

    /*!
     *  \brief Perform partition operation.
     *
     *  \param theShapes Shapes to be intersected.
     *  \param theTools Shapes to intersect theShapes.
     *  \note  Each compound from ListShapes and ListTools will be exploded in order
     *         to avoid possible intersection between shapes from this compound.
     *  \param theLimit Type of resulting shapes (corresponding to TopAbs_ShapeEnum).
     *  \param theKeepNonlimitShapes: if this parameter == 0, then only shapes of
     *                             target type (equal to Limit) are kept in the result,
     *                             else standalone shapes of lower dimension
     *                             are kept also (if they exist).
     *  \param theFuzzyParam The fuzzy tolerance to be used in the partition
     *                       algorithm, if the value is positive.
     *
     *  After implementation new version of PartitionAlgo (October 2006)
     *  other parameters are ignored by current functionality. They are kept
     *  in this function only for supporting old versions.
     *  Ignored parameters:
     *  \param theKeepInside Shapes, outside which the results will be deleted.
     *         Each shape from theKeepInside must belong to theShapes also.
     *  \param theRemoveInside Shapes, inside which the results will be deleted.
     *         Each shape from theRemoveInside must belong to theShapes also.
     *  \param theRemoveWebs If TRUE, perform Glue 3D algorithm.
     *  \param theMaterials Material indices for each shape. Make sense, only if theRemoveWebs is TRUE.
     *
     *  \return New GEOM_Object, containing the result shapes.
     */
    GEOM_Object MakePartitionWithFuzzy (in ListOfGO   theShapes,
                                        in ListOfGO   theTools,
                                        in ListOfGO   theKeepInside,
                                        in ListOfGO   theRemoveInside,
                                        in short      theLimit,
                                        in boolean    theRemoveWebs,
                                        in ListOfLong theMaterials,
                                        in short      theKeepNonlimitShapes,
                                        in double     theFuzzyParam);

    /*!
     *  \brief Perform partition operation.
     *
     *  This method may be useful if it is needed to make a partition for
     *  a compound containing nonintersected shapes. Performance will be better
     *  since intersection between shapes from compound is not performed.
     *
     *  Description of all parameters as in previous method MakePartition().
     *  One additional parameter is provided:
     *  \param IsCheckSelfInte If TRUE, perform check self intersection
     *                         of arguments before an operation.
     *  \param theFuzzyParam The fuzzy tolerance to be used in the partition
     *                       algorithm, if the value is positive.
     *
     *  \note Passed compounds (via ListShapes or via ListTools)
     *        have to consist of nonintersecting shapes.
     *
     *  \return New GEOM_Object, containing the result shapes.
     */
    GEOM_Object MakePartitionNonSelfIntersectedShapeWithFuzzy (in ListOfGO   theShapes,
                                                               in ListOfGO   theTools,
                                                               in ListOfGO   theKeepInside,
                                                               in ListOfGO   theRemoveInside,
                                                               in short      theLimit,
                                                               in boolean    theRemoveWebs,
                                                               in ListOfLong theMaterials,
                                                               in short      theKeepNonlimitShapes,
                                                               in boolean    IsCheckSelfInte,
                                                               in double     theFuzzyParam);

    /*!
     *  \brief Perform partition of the Shape with the Plane
     *  \param theShape Shape to be intersected.
     *  \param thePlane Tool shape, to intersect theShape.
     *  \param theFuzzyParam The fuzzy tolerance to be used in the partition
     *                       algorithm, if the value is positive.
     *  \return New GEOM_Object, containing the result shape.
     * 
     *  \note This operation is a shortcut to the more general \ref MakePartition
     *  operation, where \a theShape specifies single "object" (shape being partitioned)
     *  and \a thePlane specifies single "tool" (intersector shape). Other parameters of
     *  \ref MakePartition operation have default values:
     *  - \a theLimit: GEOM::SHAPE (shape limit corresponds to the type of \a theShape)
     *  - \a theKeepNonlimitShapes: 0
     *  - \a theKeepInside, \a theRemoveInside, \a theRemoveWebs,
     *    \a theMaterials (obsolete parameters): empty
     *
     * \sa MakePartition, MakePartitionNonSelfIntersectedShape
     */
    GEOM_Object MakeHalfPartitionWithFuzzy (in GEOM_Object theShape,
                                            in GEOM_Object thePlane,
                                            in double      theFuzzyParam);
  };

 // # GEOM_ICurvesOperations:
  /*!
   *  \brief Interface for curves creation.
   *
   *  Polyline, Circle, Spline (Bezier and Interpolation)
   */
  interface GEOM_ICurvesOperations : GEOM_IOperations
  {
    /*!
     *  \brief Create a circle with given center, normal vector and radius.
     *  \param thePnt Circle center.
     *  \param theVec Vector, normal to the plane of the circle.
     *  \param theR Circle radius.
     *  \return New GEOM_Object, containing the created circle.
     */
    GEOM_Object MakeCirclePntVecR (in GEOM_Object thePnt,
                                   in GEOM_Object theVec,
                                   in double theR);
    /*!
     *  \brief Create a circle, passing through three given points
     *  \param thePnt1,thePnt2,thePnt3 Points, defining the circle.
     *  \return New GEOM_Object, containing the created circle.
     */
    GEOM_Object MakeCircleThreePnt (in GEOM_Object thePnt1,
                                    in GEOM_Object thePnt2,
                                    in GEOM_Object thePnt3);
    /*!
     *  \brief Create a circle with given center, with a radius equals the distance from center to Point1
     *  and on a plane defined by all of three points.
     *  \param thePnt1,thePnt2,thePnt3 Points, defining the circle.
     *  \return New GEOM_Object, containing the created circle.
     */
    GEOM_Object MakeCircleCenter2Pnt (in GEOM_Object thePnt1,
                                      in GEOM_Object thePnt2,
                                      in GEOM_Object thePnt3);
    /*!
     *  \brief Create an ellipse with given center, normal vector and radiuses.
     *  \param thePnt Ellipse center.
     *  \param theVec Vector, normal to the plane of the ellipse.
     *  \param theRMajor Major ellipse radius.
     *  \param theRMinor Minor ellipse radius.
     *  \return New GEOM_Object, containing the created ellipse.
     */
    GEOM_Object MakeEllipse (in GEOM_Object thePnt,
                             in GEOM_Object theVec,
                             in double theRMajor,
                             in double theRMinor);

    /*!
     *  \brief Create an ellipse with given center, normal vector, main axis vector and radiuses.
     *  \param thePnt Ellipse center.
     *  \param theVec Vector, normal to the plane of the ellipse.
     *  \param theRMajor Major ellipse radius.
     *  \param theRMinor Minor ellipse radius.
     *  \param theVecMaj Vector, direction of the ellipse's main axis.
     *  \return New GEOM_Object, containing the created ellipse.
     */
    GEOM_Object MakeEllipseVec (in GEOM_Object thePnt,
                                in GEOM_Object theVec,
                                in double theRMajor,
                                in double theRMinor,
                                in GEOM_Object theVecMaj);

    /*!
     *  \brief Create an arc of circle, passing through three given points.
     *  \param thePnt1 Start point of the arc.
     *  \param thePnt2 Middle point of the arc.
     *  \param thePnt3 End point of the arc.
     *  \return New GEOM_Object, containing the created arc.
     */
    GEOM_Object MakeArc (in GEOM_Object thePnt1,
                         in GEOM_Object thePnt2,
                         in GEOM_Object thePnt3);

    /*!
     *  \brief Create an arc of circle of center C from one point to another
     *  \param theCenter Center point of the arc.
     *  \param thePnt1 Start point of the arc.
     *  \param thePnt2 End point of the arc.
     *  \param theSense Orientation of the arc
     *  \return New GEOM_Object, containing the created arc.
     */
    GEOM_Object MakeArcCenter (in GEOM_Object theCenter,
                               in GEOM_Object thePnt1,
                               in GEOM_Object thePnt2,
                               in boolean theSense);

    /*!
     *  \brief Create an arc of ellipse of center C and two points P1 P2.
     *  \param theCenter Center point of the arc.
     *  \param thePnt1 Major radius is distance from center to Pnt1.
     *  \param thePnt2 define a plane and Minor radius as a shortest
     *                 distance from Pnt2 to vector Center->Pnt1.
     *  \return New GEOM_Object, containing the created arc.
     */
    GEOM_Object MakeArcOfEllipse (in GEOM_Object theCenter,
                                  in GEOM_Object thePnt1,
                                  in GEOM_Object thePnt2);


    /*!
     *  \brief Create a polyline on the set of points.
     *  \param thePoints Sequence of points for the polyline.
     *  \param theIsClosed If TRUE, build a closed wire.
     *  \return New GEOM_Object, containing the created polyline.
     */
    GEOM_Object MakePolyline (in ListOfGO thePoints,
                              in boolean  theIsClosed);

    /*!
     *  \brief Create bezier curve on the set of points.
     *  \param thePoints Sequence of points for the bezier curve.
     *  \param theIsClosed If TRUE, build a closed curve.
     *  \return New GEOM_Object, containing the created bezier curve.
     */
    GEOM_Object MakeSplineBezier (in ListOfGO thePoints,
                                  in boolean  theIsClosed);

    /*!
     *  \brief Create B-Spline curve on the set of points.
     *  \param thePoints Sequence of points for the B-Spline curve.
     *  \param theIsClosed If TRUE, build a closed curve.
     *  \param theDoReordering If TRUE, the algo does not follow the order of
     *                         \a thePoints but searches for the closest vertex.
     *  \return New GEOM_Object, containing the created B-Spline curve.
     */
    GEOM_Object MakeSplineInterpolation (in ListOfGO thePoints,
                                         in boolean  theIsClosed,
                                         in boolean  theDoReordering);

    /*!
     *  \brief Create B-Spline curve on the set of points.
     *  \param thePoints Sequence of points for the B-Spline curve.
     *  \param theFirstVec Vector object, defining the curve direction at its first point.
     *  \param theLastVec Vector object, defining the curve direction at its last point.
     *  \return New GEOM_Object, containing the created B-Spline curve.
     */
    GEOM_Object MakeSplineInterpolWithTangents (in ListOfGO    thePoints,
                                                in GEOM_Object theFirstVec,
                                                in GEOM_Object theLastVec);

    /*!
     *  \brief Creates a curve using the parametric definition of the basic points.
     *  \param thexExpr parametric equation of the coordinates X.
     *  \param theyExpr parametric equation of the coordinates Y.
     *  \param thezExpr parametric equation of the coordinates Z.
     *  \param theParamMin the minimal value of the parameter.
     *  \param theParamMax the maximum value of the parameter.
     *  \param theParamStep the step of the parameter.
     *  \param theCurveType the type of the curve.
     *  \return New GEOM_Object, containing the created curve.
     */    
    GEOM_Object MakeCurveParametric(in string thexExpr,
				    in string theyExpr,
				    in string thezExpr,
				    in double theParamMin,
				    in double theParamMax,
				    in double theParamStep,
				    in curve_type theCurveType);

     /*!
     *  \brief Creates a curve using the parametric definition of the basic points.
     *  \param thexExpr parametric equation of the coordinates X.
     *  \param theyExpr parametric equation of the coordinates Y.
     *  \param thezExpr parametric equation of the coordinates Z.
     *  \param theParamMin the minimal value of the parameter.
     *  \param theParamMax the maximum value of the parameter.
     *  \param theParamNbStep the number of steps of the parameter discretization.
     *  \param theCurveType the type of the curve.
     *  \return New GEOM_Object, containing the created curve.
     */    
    GEOM_Object MakeCurveParametricNew(in string thexExpr,
                    in string theyExpr,
                    in string thezExpr,
                    in double theParamMin,
                    in double theParamMax,
                    in long   theParamNbStep,
                    in curve_type theCurveType);

     /*!
     *  \brief Creates an isoline curve on a face.
     *  \param theFace the face for which an isoline is created.
     *  \param IsUIsoline True for U-isoline creation; False for V-isoline
     *         creation.
     *  \param theParameter the U parameter for U-isoline or V parameter
     *         for V-isoline.
     *  \return New GEOM_Object, containing the created isoline edge or a
     *          compound of edges.
     */
    GEOM_Object MakeIsoline(in GEOM_Object theFace,
                            in boolean     IsUIsoline,
                            in double      theParameter);

    /*!
     *  \brief Create a sketcher (wire or face), following the textual description,
     *         passed through \a theCommand argument.
     *
     *  Edges of the resulting wire or face will be arcs of circles and/or linear segments. \n
     *  Format of the description string has to be the following:
     *
     *  "Sketcher[:F x1 y1]:CMD[:CMD[:CMD...]]"
     *
     *  Where:
     *  - x1, y1 are coordinates of the first sketcher point (zero by default),
     *  - CMD is one of
     *     - "R angle" : Set the direction by angle
     *     - "D dx dy" : Set the direction by DX & DY
     *     .
     *       \n
     *     - "TT x y" : Create segment by point at X & Y
     *     - "T dx dy" : Create segment by point with DX & DY
     *     - "L length" : Create segment by direction & Length
     *     - "IX x" : Create segment by direction & Intersect. X
     *     - "IY y" : Create segment by direction & Intersect. Y
     *     .
     *       \n
     *     - "C radius length" : Create arc by direction, radius and length(in degree)
     *     .
     *       \n
     *     - "WW" : Close Wire (to finish)
     *     - "WF" : Close Wire and build face (to finish)
     *
     *  \param theCommand String, defining the sketcher in local
     *                    coordinates of the working plane.
     *  \param theWorkingPlane Nine double values, defining origin,
     *                         OZ and OX directions of the working plane.
     *  \return New GEOM_Object, containing the created wire or face.
     */
    GEOM_Object MakeSketcher (in string theCommand, in ListOfDouble theWorkingPlane);

    /*!
     *  \brief Create a sketcher (wire or face), following the textual description,
     *         passed through \a theCommand argument. 
     *
     *  For format of the description string see the previous method.\n
     *
     *  \param theCommand String, defining the sketcher in local
     *                    coordinates of the working plane.
     *  \param theWorkingPlane Planar Face or LCS(Marker) of the working plane.
     *  \return New GEOM_Object, containing the created wire or face.
     */
    GEOM_Object MakeSketcherOnPlane (in string theCommand, in GEOM_Object theWorkingPlane);

    /*!
     *  \brief Create a 3D sketcher, following the textual description,
     *         passed through \a theCommand argument. 
     *
     *  Format of the description string has to be the following:
     *
     *  "3DSketcher:CMD[:CMD[:CMD...]]"
     *
     *  Where CMD is one of
     *     - "TT x y z" : Create segment by point at X & Y or set the first point
     *     - "T dx dy dz" : Create segment by point with DX & DY
     *     .
     *       \n
     *     - "OXY angleX angle2 length" : Create segment by two angles and length
     *     - "OYZ angleY angle2 length" : Create segment by two angles and length
     *     - "OXZ angleX angle2 length" : Create segment by two angles and length
     *     .
     *       \n
     *     - "WW" : Close Wire (to finish)
     *
     *  \param theCommand String, defining the sketcher in local
     *                    coordinates of the working plane.
     *  \return New GEOM_Object, containing the created wire.
     */
    GEOM_Object Make3DSketcherCommand (in string theCommand);

    /*!
     *  \brief Create a 3D sketcher, made of a straight segments, joining points
     *         with coordinates passed through \a theCoordinates argument. 
     *
     *  Order of coordinates has to be the following:
     *  x1, y1, z1, x2, y2, z2, ..., xN, yN, zN
     *
     *  \param theCoordinates List of double values.
     *  \return New GEOM_Object, containing the created wire.
     */
    GEOM_Object Make3DSketcher (in ListOfDouble theCoordinates);

    /*!
     *  \brief Create a 2D polyline (wire or a compound of wires).
     *
     *  The polyline can have several sections. Each section represents a set
     *  of points in the form of list of coordinates of the following order:
     *  x1, y1, x2, y2, ..., xN, yN
     *  Each section has its own name, type of curve (can be either
     *  GEOM::Polyline or GEOM::Interpolation) and Closed flag.
     *  For each section a wire is created. It represents either a polyline or
     *  interpolation BSpline either closed or not depending on the Closed flag.
     *  The result represents a wire if there is only one section is defined.
     *  Otherwise a compound of wires is returned.
     *
     *  \param theCoordsList the list of coordinates list. theCoordsList[0]
     *         is the coordinates list of the first section. theCoordsList[1]
     *         is for the second section etc.
     *  \param theNamesList the list of names. The order corresponds to
     *         theCoordsList.
     *  \param theTypesList the list of curve types. The order corresponds to
     *         theCoordsList.
     *  \param theClosedList the list of Closed flags. The order corresponds to
     *         theCoordsList.
     *  \param theWorkingPlane 9 double values, defining origin,
     *         OZ and OX directions of the working plane.
     *  \return New GEOM_Object, containing the created wire or a compound
     *          of wires.
     */
    GEOM_Object MakePolyline2D (in ListOfListOfDouble theCoordsList,
                                in string_array       theNamesList,
                                in short_array        theTypesList,
                                in ListOfBool         theClosedList,
                                in ListOfDouble       theWorkingPlane);

    /*!
     *  \brief Create a 2D polyline (wire or a compound of wires).
     *
     *  The polyline can have several sections. Each section represents a set
     *  of points in the form of list of coordinates of the following order:
     *  x1, y1, x2, y2, ..., xN, yN
     *  Each section has its own name, type of curve (can be either
     *  GEOM::Polyline or GEOM::Interpolation) and Closed flag.
     *  For each section a wire is created. It represents either a polyline or
     *  interpolation BSpline either closed or not depending on the Closed flag.
     *  The result represents a wire if there is only one section is defined.
     *  Otherwise a compound of wires is returned.
     *
     *  \param theCoordsList the list of coordinates list. theCoordsList[0]
     *         is the coordinates list of the first section. theCoordsList[1]
     *         is for the second section etc.
     *  \param theNamesList the list of names. The order corresponds to
     *         theCoordsList.
     *  \param theTypesList the list of curve types. The order corresponds to
     *         theCoordsList.
     *  \param theClosedList the list of Closed flags. The order corresponds to
     *         theCoordsList.
     *  \param theWorkingPlane planar Face or LCS(Marker) of the working plane.
     *  \return New GEOM_Object, containing the created wire or a compound
     *          of wires.
     */
    GEOM_Object MakePolyline2DOnPlane (in ListOfListOfDouble theCoordsList,
                                       in string_array       theNamesList,
                                       in short_array        theTypesList,
                                       in ListOfBool         theClosedList,
                                       in GEOM_Object        theWorkingPlane);

  };

 // # GEOM_ILocalOperations:
  /*!
   *  \brief Interface for fillet and chamfer creation.
   */
  interface GEOM_ILocalOperations : GEOM_IOperations
  {
    /*!
     *  \brief Perform a fillet on all edges of the given shape.
     *  \param theShape Shape, to perform fillet on.
     *  \param theR Fillet radius.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeFilletAll (in GEOM_Object theShape,
                               in double      theR);

    /*!
     *  \brief Perform a fillet on the specified edges of the given shape
     *  \param theShape Shape, to perform fillet on.
     *  \param theR Fillet radius.
     *  \param theEdges Global indices of edges to perform fillet on.
     *    \note Global index of sub-shape can be obtained, using method
     *          <VAR>GEOM_IShapesOperations.GetSubShapeIndex()</VAR>.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeFilletEdges (in GEOM_Object theShape,
                                 in double      theR,
                                 in ListOfLong  theEdges);
    GEOM_Object MakeFilletEdgesR1R2 (in GEOM_Object theShape,
                                     in double      theR1,
                                     in double      theR2,
                                     in ListOfLong  theEdges);

    /*!
     *  \brief Perform a fillet on all edges of the specified faces of the given shape.
     *  \param theShape Shape, to perform fillet on.
     *  \param theR Fillet radius.
     *  \param theFaces Global indices of faces to perform fillet on.
     *    \note Global index of sub-shape can be obtained, using method
     *          <VAR>GEOM_IShapesOperations.GetSubShapeIndex()</VAR>.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeFilletFaces (in GEOM_Object theShape,
                                 in double      theR,
                                 in ListOfLong  theFaces);

    GEOM_Object MakeFilletFacesR1R2 (in GEOM_Object theShape,
                                     in double      theR1,
                                     in double      theR2,
                                     in ListOfLong  theFaces);

    /*!
     *  \brief Perform a fillet on a face or a shell at the specified vertexes.
     *  \param theShape Shape, to perform fillet on.
     *  \param theR Fillet radius.
     *  \param theVertexes Global indices of vertexes to perform fillet on.
     *    \note Global index of sub-shape can be obtained, using method
     *          <VAR>GEOM_IShapesOperations.GetSubShapeIndex()</VAR>.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeFillet2D (in GEOM_Object theShape,
                              in double      theR,
                              in ListOfLong  theVertexes);

    /*!
     *  \brief Perform a fillet on edges of the specified vertexes of the given wire.
     *  \param theShape Shape, to perform fillet on.
     *  \param theR Fillet radius.
     *  \param theVertexes Global indices of vertexes to perform fillet on.
     *    \note Global index of sub-shape can be obtained, using method
     *          <VAR>GEOM_IShapesOperations.GetSubShapeIndex()</VAR>.
     *    \note The list of vertices could be empty, in this case fillet fill be done
     *          at all vertices in given wire
     *  \param doIgnoreSecantVertices If FALSE, fillet radius is always limited
     *         by the length of the edges, nearest to the fillet vertex.
     *         But sometimes the next edge is C1 continuous with the one, nearest to
     *         the fillet point, and such two (or more) edges can be united to allow
     *         bigger radius. Set this flag to TRUE to allow collinear edges union,
     *         thus ignoring the secant vertex (vertices).
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeFillet1D (in GEOM_Object theShape,
                              in double      theR,
                              in ListOfLong  theVertexes,
                              in boolean     doIgnoreSecantVertices);

    /*!
     *  \brief Perform a symmetric chamfer on all edges of the given shape.
     *  \param theShape Shape, to perform chamfer on.
     *  \param theD Chamfer size along each face.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeChamferAll (in GEOM_Object theShape,
                                in double      theD);

    /*!
     *  \brief Perform a chamfer on edges, common to the specified faces.
     *  with distance D1 on the Face1
     *  \param theShape Shape, to perform chamfer on.
     *  \param theD1 Chamfer size along \a theFace1.
     *  \param theD2 Chamfer size along \a theFace2.
     *  \param theFace1,theFace2 Global indices of two faces of \a theShape.
     *    \note Global index of sub-shape can be obtained, using method
     *          <VAR>GEOM_IShapesOperations.GetSubShapeIndex()</VAR>.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeChamferEdge (in GEOM_Object theShape,
                                 in double theD1, in double theD2,
                                 in long theFace1, in long theFace2);
    /*!
     *  \brief The Same but with params theD = Chamfer Length
     *  and theAngle = Chamfer Angle (Angle in radians)
     */
    GEOM_Object MakeChamferEdgeAD (in GEOM_Object theShape,
                                   in double theD, in double theAngle,
                                   in long theFace1, in long theFace2);

    /*!
     *  \brief Perform a chamfer on all edges of the specified faces.
     *  with distance D1 on the first specified face (if several for one edge)
     *  \param theShape Shape, to perform chamfer on.
     *  \param theD1 Chamfer size along face from \a theFaces. If both faces,
     *               connected to the edge, are in \a theFaces, \a theD1
     *               will be get along face, which is nearer to \a theFaces beginning.
     *  \param theD2 Chamfer size along another of two faces, connected to the edge.
     *  \param theFaces Sequence of global indices of faces of \a theShape.
     *    \note Global index of sub-shape can be obtained, using method
     *          <VAR>GEOM_IShapesOperations.GetSubShapeIndex()</VAR>.
     *  \return New GEOM_Object, containing the result shape.
     */
    GEOM_Object MakeChamferFaces (in GEOM_Object theShape,
                                  in double theD1, in double theD2,
                                  in ListOfLong theFaces);
    /*!
     *  The Same but with params theD = Chamfer Length
     *  and theAngle = Chamfer Angle (Angle in radians)
     */
    GEOM_Object MakeChamferFacesAD (in GEOM_Object theShape,
                                    in double theD, in double theAngle,
                                    in ListOfLong theFaces);

   /*!
    *  \brief Perform a chamfer on edges,
    *  with distance D1 on the first specified face (if several for one edge)
    *  \param theShape Shape, to perform chamfer on.
    *  \param theD1,theD2 Chamfer size
    *  \param theEdges Sequence of edges of \a theShape.
    *  \return New GEOM_Object, containing the result shape.
    */
    GEOM_Object MakeChamferEdges (in GEOM_Object theShape,
                                  in double theD1, in double theD2,
                                  in ListOfLong theEdges);
    /*!
     *  The Same but with params theD = Chamfer Length
     *  and theAngle = Chamfer Angle (Angle in radians)
     */
    GEOM_Object MakeChamferEdgesAD (in GEOM_Object theShape,
                                    in double theD, in double theAngle,
                                    in ListOfLong theEdges);

    /*!
     *  \brief Perform an Archimde operation on the given shape with given parameters.
     *                    The object presenting the resulting face is returned
     *  \param theShape Shape to be put in water.
     *  \param theWeight Weight og the shape.
     *  \param theWaterDensity Density of the water.
     *  \param theMeshDeflection Deflection od the mesh, using to compute the section.
     *  \return New GEOM_Object, containing a section of \a theShape
     *          by a plane, corresponding to water level.
     */
    GEOM_Object MakeArchimede (in GEOM_Object theShape,
                               in double theWeight,
                               in double theWaterDensity,
                               in double theMeshDeflection);

    /*!
     *  \brief Duplicates <VAR>GEOM_IShapesOperations.GetSubShapeIndex()</VAR>.
     *
     *  Present here only for compatibility.
     */
    long GetSubShapeIndex (in GEOM_Object theShape, in GEOM_Object theSubShape);
  };

 // #  GEOM_IHealingOperations: 
  /*!
   *  \brief Interface for shape healing operations
   *
   *  Shape Processing, SuppressFaces, etc.
   */
  interface GEOM_IHealingOperations : GEOM_IOperations
  {
    /*!
     *  \brief Apply a sequence of Shape Healing operators to the given object.
     *  \param theShapes Shape to be processed.
     *  \param theOperators List of names of operators ("FixShape", "SplitClosedFaces", etc.).
     *  \param theParameters List of names of parameters
     *                    ("FixShape.Tolerance3d", "SplitClosedFaces.NbSplitPoints", etc.).
     *  \param theValues List of values of parameters, in the same order
     *                    as parameters are listed in \a theParameters list.
     *  \return New GEOM_Object, containing processed shape.
     */
    GEOM_Object ProcessShape (in GEOM_Object theShapes,
                              in string_array theOperators,
                              in string_array theParameters,
                              in string_array theValues);

    /*!
     *  \brief Get default sequence of operators, their parameters and parameters' values
     *  of Shape Process operation. 
     *
     *  In the current implementation the defaults are
     *  read from the file pointed by CSF_ShHealingDefaults environmental variable.
     *  \param theOperators Output. Default list of names of operators.
     *  \param theParameters Output. Default list of names of parameters.
     *  \param theValues Output. List of default values of parameters, in the same order
     *                           as parameters are listed in \a theParameters list.
     */
    void GetShapeProcessParameters (out string_array theOperators,
                                    out string_array theParameters,
                                    out string_array theValues);
    /*!
     *  \brief Get parameters and parameters' values for the given Shape Process operation.
     *
     *  In the current implementation the defaults are
     *  read from the file pointed by CSF_ShHealingDefaults environmental variable.
     *  \param theOperator Input. The operator's name.
     *  \param theParameters Output. Default list of names of parameters.
     *  \param theValues Output. List of default values of parameters, in the same order
     *                           as parameters are listed in \a theParameters list.
     */
    void GetOperatorParameters (in string theOperator,
                                out string_array theParameters,
                                out string_array theValues);

    /*!
     *  \brief Remove faces from the given object (shape).
     *  \param theObject Shape to be processed.
     *  \param theFaces Indices of faces to be removed, if EMPTY then the method
     *                  removes ALL faces of the given object.
     *  \return New GEOM_Object, containing processed shape.
     */
    GEOM_Object SuppressFaces (in GEOM_Object theObject, in short_array theFaces);

    /*!
     *  \brief Close an open wire.
     *  \param theObject Shape to be processed.
     *  \param theWires Indexes of edge(s) and wire(s) to be closed within <VAR>theObject</VAR>'s shape,
     *                  if -1, then theObject itself is a wire.
     *  \param isCommonVertex If TRUE : closure by creation of a common vertex,
     *                        If FALS : closure by creation of an edge between ends.
     *  \return New GEOM_Object, containing processed shape.
     */
    GEOM_Object CloseContour (in GEOM_Object theObject, in short_array theWires,
                              in boolean isCommonVertex);

    /*!
     *  \brief Remove internal wires and edges from the given object (face).
     *  \param theObject Shape to be processed.
     *  \param theWires Indices of wires to be removed, if EMPTY then the method
     *                  removes ALL internal wires of the given object.
     *  \return New GEOM_Object, containing processed shape.
     */
    GEOM_Object RemoveIntWires (in GEOM_Object theObject, in short_array theWires);

    /*!
     *  \brief Remove internal closed contours (holes) from the given object.
     *  \param theObject Shape to be processed.
     *  \param theWires Indices of wires to be removed, if EMPTY then the method
     *                  removes ALL internal holes of the given object
     *  \return New GEOM_Object, containing processed shape.
     */
    GEOM_Object FillHoles (in GEOM_Object theObject, in short_array theWires);

    /*!
     *  Sewing of the given object.
     *  \param theObjects Shapes to be processed.
     *  \param theTolerance Required tolerance value.
     *  \return New GEOM_Object, containing processed shape.
     */
    GEOM_Object Sew (in ListOfGO theObjects, in double theTolerance);

    /*!
     *  Sewing of the given object. Allows non-manifold sewing.
     *  \param theObjects Shapes to be processed.
     *  \param theTolerance Required tolerance value.
     *  \return New GEOM_Object, containing processed shape.
     */
    GEOM_Object SewAllowNonManifold(in ListOfGO theObjects, in double theTolerance);

    /*!
     *  Rebuild the topology of theSolids by removing
     *  the faces that are shared by several solids.
     *  \param theSolids A list of shapes containing solids to be processed.
     *  \return New GEOM_Object, containing processed shape.
     */
    GEOM_Object RemoveInternalFaces (in ListOfGO theSolids);

    /*!
     *  \brief Addition of a point to a given edge of \a theObject.
     *  \param theObject Shape to be processed.
     *  \param theEdgeIndex Index of edge to be divided within theObject's shape,
     *                      if -1, then theObject itself is the edge.
     *  \param theValue Value of parameter on edge or length parameter,
     *                  depending on \a isByParameter.
     *  \param isByParameter If TRUE : \a theValue is treated as a curve parameter [0..1],
     *                       if FALSE : \a theValue is treated as a length parameter [0..1]
     *  \return New GEOM_Object, containing the processed shape.
     */
    GEOM_Object DivideEdge (in GEOM_Object theObject, in short theEdgeIndex,
                            in double theValue, in boolean isByParameter);

    /*!
     *  \brief Addition of points to a given edge of \a theObject by projecting
     *         other points to the given edge.
     *  \param theObject Shape to be processed.
     *  \param theEdgeIndex Index of edge to be divided within theObject's shape,
     *                      if -1, then theObject itself is the edge.
     *  \param thePoints Points to project to theEdgeIndex-th edge.
     *  \return New GEOM_Object, containing the processed shape.
     */
    GEOM_Object DivideEdgeByPoint (in GEOM_Object theObject,
                                   in short       theEdgeIndex,
                                   in ListOfGO    thePoints);

    /*!
     *  \brief Suppress the vertices in the wire in case if adjacent edges are C1 continuous.
     *  \param theWire Wire to minimize the number of C1 continuous edges in.
     *  \param theVertices A list of vertices to suppress. If the list
     *                     is empty, all vertices in a wire will be assumed.
     *  \return New GEOM_Object with modified wire.
     */
    GEOM_Object FuseCollinearEdgesWithinWire (in GEOM_Object theWire,
                                              in ListOfGO theVertices);

    /*!
     *  \brief Get a list of wires (wrapped in GEOM_Object-s),
     *  that constitute a free boundary of the given shapes.
     *  \param theObjects Shapes to get free boundary of.
     *  \param theClosedWires Output. Closed wires on the free boundary of the given shape.
     *  \param theOpenWires Output. Open wires on the free boundary of the given shape.
     *  \return FALSE, if an error(s) occurred during the method execution.
     */
    boolean GetFreeBoundary (in  ListOfGO theObjects,
                             out ListOfGO theClosedWires,
                             out ListOfGO theOpenWires);

    /*!
     *  \brief Change orientation of the given object.
     *  \param theObject Shape to be processed.
     *  \return New GEOM_Object, containing processed shape.
     */
    GEOM_Object ChangeOrientation (in GEOM_Object theObject);
    GEOM_Object ChangeOrientationCopy (in GEOM_Object theObject);

    /*!
     *  \brief Try to limit tolerance of the given object by value \a theTolerance.
     *  \param theObject Shape to be processed.
     *  \param theTolerance Required tolerance value.
     *  \return New GEOM_Object, containing processed shape.
     */
    GEOM_Object LimitTolerance (in GEOM_Object theObject, in double theTolerance);

    /*!
     *  \brief Provides Python dump functionality for algorithms entirely implemented in Python.
     *  \param theObject Shape to be processed.
     *  \param result Shape of the algorithm execution.
     *  \param imports module import for current functon.
     *  \param funcName name of a Python function that we need to put into dump.
     *  \param args arguments of the Python function.
     */
    void FuncToPythonDump(in GEOM_Object theObject, in GEOM_Object result, in string imports, in string funcName, in string args);


    /*!
     *  \brief Return information on what has been done by the last called healing method.
     *  \return ModifStatistics, information container.
     */
    ModifStatistics GetStatistics();
  };

 // # GEOM_IInsertOperations:
  /*!
   *  \brief Interface for shape insert operations (like copy, import).
   *
   */
  interface GEOM_IInsertOperations : GEOM_IOperations
  {
    /*!
     *  \brief Create a copy of the given object
     */
    GEOM_Object MakeCopy (in GEOM_Object theOriginal);

    /*!
     *  \brief Deprecated method. Use Export\<FormatName\> (from the
     *  corresponding plugin) instead; here \<FormatName\> is a name of format.
     *
     *  \brief Export the given shape into a file with given name.
     *  \param theObject Shape to be stored in the file.
     *  \param theFileName Name of the file to store the given shape in.
     *  \param theFormatName Specify format for the shape storage.
     */
    void Export (in GEOM_Object theObject, in string theFileName, in string theFormatName);

    /*!
     *  \brief Deprecated method. Use Import\<FormatName\> (from the
     *  corresponding plugin) instead; here \<FormatName\> is a name of format.
     *
     *  \brief Import a shape from the STL, BREP, IGES or STEP file
     *  (depends on given format) with given name.
     *  \param theFileName The file, containing the shape.
     *  \param theFormatName Specify format for the file reading.
     *         If format 'IGES_SCALE' is used instead of 'IGES' or
     *            format 'STEP_SCALE' is used instead of 'STEP',
     *            file length unit will be ignored (set to 'meter') and result model will be scaled.
     *  \return List of GEOM_Object, containing the created shape and groups of materials.
     */
    ListOfGBO ImportFile (in string theFileName, in string theFormatName);

    /*!
     *  \brief Deprecated method. Use ReadValue (from the corresponding plugin) instead.
     *
     *  \brief Read a value of parameter from a file, containing a shape.
     *  \param theFileName The file, containing the shape.
     *  \param theFormatName Specify format for the file reading.
     *  \param theParameterName Specify the parameter. For example, pass "LEN_UNITS"
     *                          to obtain length units, in which the file is written.
     *  \return Value of requested parameter in form of text string.
     */
    string ReadValue (in string theFileName, in string theFormatName, in string theParameterName);

    /*!
     *  \brief Read a shape from the binary stream, containing its bounding representation (BRep).
     *  \note GEOM_Object::GetShapeStream() method can be used to obtain the shape's BRep stream.
     *  \param theStream The BRep binary stream.
     *  \return New GEOM_Object, containing the shape, read from theStream.
     */
    GEOM_Object RestoreShape (in SALOMEDS::TMPFile theStream);

    /*!
     * \brief Load texture from file
     * \param theTextureFile texture file name
     * \return unique texture identifier
     */
    long LoadTexture(in string theTextureFile);

    /*!
     * \brief Add texture to the study
     * \param theWidth texture width in pixels
     * \param theHeight texture height in pixels
     * \param theTexture texture byte array
     * \return unique texture identifier
     */
    long AddTexture(in long theWidth, in long theHeight, in SALOMEDS::TMPFile theTexture);

    /*!
     * \brief Get previously loaded texture data
     * \param theID texture identifier
     * \param theWidth texture width in pixels
     * \param theHeight texture height in pixels
     * \return texture byte array
     */
    SALOMEDS::TMPFile GetTexture(in long theID, out long theWidth, out long theHeight);

    /*!
     * \brief Get list of all available texture IDs
     * \return list of all texture IDs available for the current study
     */
    ListOfLong GetAllTextures();

    /*!
     *  \brief Non-topological information transfer datum.
     */
    struct TransferDatum
    {
      string myName;
      long   myNumber;
      long   myMaxNumber;
    };

    /*!
     *  \brief Sequence of non-topological information transfer data.
     */
    typedef sequence<TransferDatum> ListOfTransferDatum;

    /*!
     *  \brief Transfer non-topological data from one object to another
     *  \param theObjectFrom the source object of non-topological data
     *  \param theObjectTo the destination object of non-topological data
     *  \param theFindMethod method to search sub-shapes of theObjectFrom
     *         in shape theObjectTo. Possible values are: GEOM::FSM_GetInPlace,
     *         GEOM::FSM_GetInPlaceByHistory and GEOM::FSM_GetInPlace_Old.
     *         Other values of GEOM::find_shape_method are not supported.
     *  \param theResult statistics of the operation. Output parameter. It
     *         represents a sequence of Transfer Datum. A datum has the type
     *         (string code), the total number of items of this type and
     *         the number of transferred items.
     *  \return true in case of success; otherwise false.
     */
    boolean TransferData(in  GEOM_Object         theObjectFrom,
                         in  GEOM_Object         theObjectTo,
                         in  find_shape_method   theFindMethod,
                         out ListOfTransferDatum theResult);

  };

 // # GEOM_IKindOfShape:
  /*!
   *  \brief Interface for shape_kind enumeration.
   */
  interface GEOM_IKindOfShape
  {
    enum shape_kind {
      NO_SHAPE,
      //COMPOSITEs
      COMPOUND,
      COMPSOLID,
      SHELL,
      WIRE,
      // SOLIDs
      /*! full sphere */
      SPHERE,
      /*! cylinder */
      CYLINDER,
      /*! box with faces, parallel to global coordinate planes */
      BOX,
      /*! other box */
      ROTATED_BOX, 
      /*! full torus */
      TORUS,   
      /*! cone */  
      CONE,   
      /*! solid, bounded by polygons */
      POLYHEDRON,  
      /*! other solid */
      SOLID,       
      // FACEs
      /*! spherical face (closed) */
      SPHERE2D,    
      /*! cylindrical face with defined height */
      CYLINDER2D,
      /*! toroidal face (closed) */
      TORUS2D,     
      /*! conical face with defined height */
      CONE2D,
      /*! planar, bounded by circle */
      DISK_CIRCLE,
      /*! planar, bounded by ellipse */
      DISK_ELLIPSE,
      /*! planar, bounded by segments */
      POLYGON,     
      /*! infinite planar */
      PLANE,        
       /*! other planar */
      PLANAR,      
      /*! other face */
      FACE,      
      // EDGEs
      /*! full circle */
      CIRCLE,      
      /*! arc of circle */
      ARC_CIRCLE, 
      /*! full ellipse */
      ELLIPSE,    
      /*! arc of ellipse */
      ARC_ELLIPSE,  
      /*! infinite segment */
      LINE,         
      /*! segment */
      SEGMENT,      
      /*! B-Spline curve */
      CRV_BSPLINE,  
      /*! Bezier curve */
      CRV_BEZIER,  
      /*! hyperbola */
      HYPERBOLA,  
      /*! parabola */
      PARABOLA,  
      /*! other edge */
      EDGE,       
      // VERTEX
      VERTEX,
      // ADVANCED shapes
      LCS,
      /*! all advanced shapes (temporary implementation) */
      ADVANCED    
    };
  };

 // # GEOM_IMeasureOperations:
  /*!
   *  \brief Interface for measurement (distance, whatis) and
   *  properties calculation (like Centre of Mass, Inertia, etc.).
   *
   */
  interface GEOM_IMeasureOperations : GEOM_IOperations
  {
    /*!
     *  \brief Get kind of theShape.
     *  \param theShape Shape to get a kind of.
     *  \param theIntegers Output. Integer and enumerated shape's parameters
     *                     (kind of surface, closed/unclosed, number of edges, etc.)
     *  \param theDoubles  Output. Double shape's parameters (coordinates, dimensions, etc.)
     *  \note  Concrete meaning of each value, returned via \a theIntegers
     *         or \a theDoubles list depends on the kind of the shape.
     *  \return Returns a kind of shape in terms of <VAR>GEOM_IKindOfShape.shape_kind</VAR> enumeration.
     */
    //short KindOfShape (in GEOM_Object   theShape,
    GEOM_IKindOfShape::shape_kind KindOfShape (in  GEOM_Object  theShape,
                                               out ListOfLong   theIntegers,
                                               out ListOfDouble theDoubles);

    /*!
     *  \brief Get position (LCS) of theShape.
     *  \param theShape Shape to calculate position of.
     *  \param Ox,Oy,Oz Output. Coordinates of shape's location origin.
     *                  Origin of the LCS is situated at the shape's center of mass.
     *  \param Zx,Zy,Zz Output. Coordinates of shape's location normal(main) direction.
     *  \param Xx,Xy,Xz Output. Coordinates of shape's location X direction.
     *                  Axes of the LCS are obtained from shape's location or,
     *                  if the shape is a planar face, from position of its plane.
     *  \return Returns position of the shape through the last nine arguments.
     */
    void GetPosition (in GEOM_Object theShape,
                      out double Ox, out double Oy, out double Oz,
                      out double Zx, out double Zy, out double Zz,
                      out double Xx, out double Xy, out double Xz);

    /*!
     *  \brief Get summarized length of all wires,
     *  area of surface and volume of the given shape.
     *  \param theShape Shape to define properties of.
     *  \param theTolerance maximal relative error of area and volume computation.
     *  \param theLength Output. Summarized length of all wires of the given shape.
     *  \param theSurfArea Output. Area of surface of the given shape.
     *  \param theVolume Output. Volume of the given shape.
     *  \return Returns shape properties through the last three arguments.
     */
    void GetBasicProperties (in GEOM_Object theShape,
                             in double theTolerance,
                             out double theLength,
                             out double theSurfArea,
                             out double theVolume);

    /*!
     *  \brief Get a point, situated at the centre of mass of theShape.
     *  \param theShape Shape to define centre of mass of.
     *  \return New GEOM_Object, containing the created point.
     */
    GEOM_Object GetCentreOfMass (in GEOM_Object theShape);

    /*
     *  Get the vertex by index for 1D objects
     *  \param theShape Shape (wire or edge) to find the vertex on it
     *  \param theIndex Index of vertex sub-shape
     *  \param theUseOri To consider edge/wire orientation or not
     *  \return New GEOM_Object, vertex.
     */
    GEOM_Object GetVertexByIndex( in GEOM_Object theShape, in long theIndex, in boolean theUseOri );

    /*!
     *  \brief Get a vector, representing the normal of theFace.
     *  If the face is not planar, theOptionalPoint is obligatory.
     *  \param theFace Shape (face) to define the normal of.
     *  \param theOptionalPoint Shape (point) to define the normal at.
     *                          Can be NULL in case of planar face.
     *  \return New GEOM_Object, containing the created normal vector.
     */
    GEOM_Object GetNormal (in GEOM_Object theFace,
                           in GEOM_Object theOptionalPoint);

    /*!
     *  \brief Get inertia matrix and moments of inertia of theShape.
     *  \param theShape Shape to calculate inertia of.
     *  \param I11,I12,I13,I21,I22,I23,I31,I32,I33 Output. Components of the inertia matrix of the given shape.
     *  \param Ix,Iy,Iz Output. Moments of inertia of the given shape.
     *  \return Returns inertia through the last twelve arguments.
     */
    void GetInertia (in GEOM_Object theShape,
                     out double I11, out double I12, out double I13,
                     out double I21, out double I22, out double I23,
                     out double I31, out double I32, out double I33,
                     out double Ix , out double Iy , out double Iz);

    /*!
     *  \brief Get parameters of bounding box of the given shape
     *  \param theShape Shape to obtain bounding box of.
     *  \param precise TRUE for precise computation; FALSE for fast one.
     *  \param Xmin,Xmax Output. Limits of shape along OX axis.
     *  \param Ymin,Ymax Output. Limits of shape along OY axis.
     *  \param Zmin,Zmax Output. Limits of shape along OZ axis.
     *  \return Returns parameters of bounding box through the last six arguments.
     */
    void GetBoundingBox (in GEOM_Object theShape,
                         in boolean precise,
                         out double Xmin, out double Xmax,
                         out double Ymin, out double Ymax,
                         out double Zmin, out double Zmax);

    /*!
     *  \brief Get bounding box of the given shape
     *  \param theShape Shape to obtain bounding box of.
     *  \param precise TRUE for precise computation; FALSE for fast one.
     *  \return New GEOM_Object, containing the created bounding box.
     */
    GEOM_Object MakeBoundingBox (in GEOM_Object theShape,
                                 in boolean precise);

    /*!
     *  \brief Get min and max tolerances of sub-shapes of theShape
     *  \param theShape Shape, to get tolerances of.
     *  \param FaceMin,FaceMax Output. Min and max tolerances of the faces.
     *  \param EdgeMin,EdgeMax Output. Min and max tolerances of the edges.
     *  \param VertMin,VertMax Output. Min and max tolerances of the vertices.
     *  \return Returns shape tolerances through the last six arguments.
     */
    void GetTolerance (in GEOM_Object theShape,
                       out double FaceMin, out double FaceMax,
                       out double EdgeMin, out double EdgeMax,
                       out double VertMin, out double VertMax);

    /*!
     *  \brief Enumeration of Shape defects coming from CheckShape algorithms.
     */
    enum ShapeErrorType
    {
      /* for vertices */
      InvalidPointOnCurve,
      InvalidPointOnCurveOnSurface,
      InvalidPointOnSurface,

      /* for edges */
      No3DCurve,
      Multiple3DCurve,
      Invalid3DCurve,
      NoCurveOnSurface,
      InvalidCurveOnSurface,
      InvalidCurveOnClosedSurface,
      InvalidSameRangeFlag,
      InvalidSameParameterFlag,
      InvalidDegeneratedFlag,

      FreeEdge,
      InvalidMultiConnexity,
      InvalidRange,

      /* for wires */
      EmptyWire,
      RedundantEdge,
      SelfIntersectingWire, /* on a face */

      /* for faces */
      NoSurface,
      InvalidWire,
      RedundantWire,
      IntersectingWires,
      InvalidImbricationOfWires,

      /* for shells */
      EmptyShell,
      RedundantFace,

      /* for shapes */
      UnorientableShape,
      NotClosed,
      NotConnected,

      SubshapeNotInShape,

      BadOrientation,
      BadOrientationOfSubshape,

      InvalidToleranceValue,

      /* for exception */
      CheckFail
    };

    /*!
     *  \brief Description of a shape defect: type and incriminated sub-shapes.
     */
    struct ShapeError
    {
      ShapeErrorType error;
      ListOfLong     incriminated;
    };

    /*!
     *  \brief Sequence of all shape defects.
     */
    typedef sequence<ShapeError> ShapeErrors;

    /*!
     *  \brief Check a topology of the given shape.
     *  \param theShape Shape to check validity of.
     *  \param theErrors Structure, containing discovered errors and incriminated sub-shapes.
     *  \return TRUE, if the shape "seems to be valid" from the topological point of view.
     */
    boolean CheckShape (in GEOM_Object  theShape,
                        out ShapeErrors theErrors);

    /*!
     *  \brief Check a topology and a geometry of the given shape.
     *  \param theShape Shape to check validity of.
     *  \param theErrors Structure, containing discovered errors and incriminated sub-shapes.
     *  \return TRUE, if the shape "seems to be valid".
     */
    boolean CheckShapeWithGeometry (in GEOM_Object  theShape,
                                    out ShapeErrors theErrors);

    /*!
     *  \brief Convert sequence of shape errors, returned by
     *  <VAR>CheckShape()</VAR> or <VAR>CheckShapeWithGeometry()</VAR>, into string.
     *  \param theShape the invalid shape.
     *  \param theErrors The sequence of \a theShape errors.
     *  \return String, describing all the errors in form, suitable for printing.
     */
    string PrintShapeErrors (in GEOM_Object theShape,
                             in ShapeErrors theErrors);

    /*!
     *  \brief Check a topology of the given shape on self-intersections presence.
     *  \param theShape Shape to check validity of.
     *  \param theCheckLevel the level of self-interference check.
     *  \param theIntersections Output. List of intersected sub-shapes IDs, it contains pairs of IDs.
     *  \return TRUE, if the shape does not have any self-intersections.
     */
    boolean CheckSelfIntersections (in GEOM_Object theShape,
                                    in long        theCheckLevel,
                                    out ListOfLong theIntersections);

    /*!
     *  \brief Detect self-intersections of the given shape with algorithm based on mesh intersections.
     *  \param theShape Shape to check validity of.
     *  \param theDeflection Linear deflection coefficient that specifies quality of tessellation.
     *  \param theTolerance Specifies a distance between sub-shapes used for detecting gaps:
     *                       - if \a theTolerance <= 0, algorithm detects intersections
     *                       - if \a theTolerance > 0, algorithm detects gaps
     *  \param theIntersections Output. List of intersected sub-shapes IDs, it contains pairs of IDs.
     *  \return TRUE, if the shape does not have any self-intersections.
     */
    boolean CheckSelfIntersectionsFast (in GEOM_Object theShape,
					in float       theDeflection,
					in double      theTolerance,
					out ListOfLong theIntersections);

    /*!
     *  \brief Check boolean and partition operations arguments.
     *  \param theShape the argument of an operation to be checked.
     *  \return TRUE if the argument is valid for a boolean or partition
     *          operation; FALSE otherwise.
     */
    boolean CheckBOPArguments (in GEOM_Object theShape);

    /*!
     *  \brief Detect intersections of the given shapes with algorithm based on mesh intersections.
     *  \param theShape1 First source object
     *  \param theShape2 Second source object
     *  \param theTolerance Specifies a distance between shapes used for detecting gaps:
     *                       - if \a theTolerance <= 0, algorithm detects intersections
     *                       - if \a theTolerance > 0, algorithm detects gaps
     *  \param theDeflection Linear deflection coefficient that specifies quality of tessellation:
     *                       - if \a theDeflection <= 0, default deflection 0.001 is used
     *  \param theIntersections1 Output: contains list of sub-shapes IDs from 1st shape that localize intersection
     *  \param theIntersections2 Output: contains list of sub-shapes IDs from 2nd shape that localize intersection
     *  \return TRUE, if the are intersections (gaps) between source shapes
     */
    boolean FastIntersect (in GEOM_Object theShape1,
			   in GEOM_Object theShape2,
			   in double      theTolerance,
			   in float       theDeflection,
			   out ListOfLong theIntersections1,
			   out ListOfLong theIntersections2);

    /*!
     *  \brief Check if the given shape can be an argument for MakeSolid operation
     *  \param theShape Shape to be described.
     *  \return Empty string if a solid can be made on this shape, error code otherwise.
     */
    string IsGoodForSolid (in GEOM_Object theShape);

    /*!
     *  O\brief btain description of the given shape
     *  \param theShape Shape to be described.
     *  \return Description of the given shape.
     */
    string WhatIs (in GEOM_Object theShape);

    /*!
     *  \brief Check if points defined by coords = [x1, y1, z1, x2, y2, z2, ...] are inside or on
     *  the shape theShape.
     *  \param theShape Shape to check.
     *  \param coords list of coordinates.
     *  \param tolerance tolerance.
     *  \return list of boolean.
     */
    ListOfBool AreCoordsInside(in GEOM_Object theShape, in ListOfDouble coords, in double tolerance);

    /*!
     *  \brief Get minimal distance between the given shapes.
     *  \param theShape1,theShape2 Shapes to find minimal distance between.
     *  \param X1,Y1,Z1 Output. Coordinates of point on theShape1, nearest to theShape2.
     *  \param X2,Y2,Z2 Output. Coordinates of point on theShape2, nearest to theShape1.
     *  \return Value of the minimal distance between the given shapes.
     */
    double GetMinDistance (in GEOM_Object theShape1, in GEOM_Object theShape2,
                           out double X1, out double Y1, out double Z1,
                           out double X2, out double Y2, out double Z2);

    /*!
     *  \brief Get closest points of the given shapes.
     *  \param theShape1,theShape2 Shapes to find closest points of.
     *  \param theCoords Output. List of (X, Y, Z) coordinates for all couples of points.
     *  \return The number of found solutions (-1 in case of infinite number of solutions).
     */
    long ClosestPoints (in GEOM_Object theShape1,
                        in GEOM_Object theShape2,
                        out ListOfDouble theCoords);

    /*!
     *  \brief Get angle between the given lines or linear edges.
     *  \param theShape1,theShape2 Shapes to find angle between. Lines or linear edges.
     *  \return Value of the angle between the given shapes.
     */
    double GetAngle (in GEOM_Object theShape1, in GEOM_Object theShape2);

    /*!
     *  \brief Get angle between the given vectors.
     *  \param theShape1,theShape2 Vectors to find angle between.
     *  \return Value of the angle between the given vectors.
     */
    double GetAngleBtwVectors (in GEOM_Object theShape1, in GEOM_Object theShape2);

    /*!
     *  \brief The function takes a single face with holes and returns a list of faces,
     *  first of them is the original face without holes, and the other faces are placed
     *  on the same surface as the original face but bounded by each hole wire.
     *  If the original face has no holes, it will be returned as an output
     *  \param theShape face, to perform operation.
     *  \return ListOfGO, containing the result original face and faces from holes.
     */
    ListOfGO PatchFace(in GEOM_Object theShape);

    /*!
     *  \brief Get point coordinates
     */
    void PointCoordinates (in GEOM_Object theShape, out double X, out double Y, out double Z);

    /*!
     *  \brief Get radius of curvature of curve in the point determinated by param
     *  \param theShape - curve.
     *  \param theParam - parameter on curve
     *  \return Value of curvature.
     */
    double CurveCurvatureByParam (in GEOM_Object theShape, in double theParam);

    /*!
     *  \brief Get radius of curvature of curve in the given point
     *  \param theShape - curve.
     *  \param thePoint - point
     *  \return Value of curvature.
     */
    double CurveCurvatureByPoint (in GEOM_Object theShape, in GEOM_Object thePoint);

    /*!
     *  \brief Get max radius of curvature of surface in the point determinated by params
     *  \param theShape - surface.
     *  \param theUParam - U-parameter on surface
     *  \param theVParam - V-parameter on surface
     *  \return Value of curvature.
     */
    double MaxSurfaceCurvatureByParam (in GEOM_Object theShape, in double theUParam,
                                       in double theVParam);

    /*!
     *  \brief Get max radius of curvature of surface in the given point
     *  \param theShape - surface.
     *  \param thePoint - point
     *  \return Value of curvature.
     */
    double MaxSurfaceCurvatureByPoint (in GEOM_Object theShape, in GEOM_Object thePoint);

    /*!
     *  \brief Get min radius of curvature of surface in the point determinated by params
     *  \param theShape - surface.
     *  \param theUParam - U-parameter on surface
     *  \param theVParam - V-parameter on surface
     *  \return Value of curvature.
     */
    double MinSurfaceCurvatureByParam (in GEOM_Object theShape, in double theUParam,
                                       in double theVParam);

    /*!
     *  \brief Get min radius of curvature of surface in the given point
     *  \param theShape - surface.
     *  \param thePoint - point
     *  \return Value of curvature.
     */
    double MinSurfaceCurvatureByPoint (in GEOM_Object theShape, in GEOM_Object thePoint);

    /*!
     *  \brief Get vector of curvature of surface in the given point along the given direction.
     *  \param theShape - face.
     *  \param thePoint - point.
     *  \param theDirection - direction.
     *  \note  Before the calculation of curvature, the point and the direction
     *         are projected to the face, if the point does not lay on it or
     *         the direction is not tangent to it initially.
     *  \return Vector of curvature. The returned vector is codirectional with
     *          the normal to the face in the given point in case of positive
     *          curvature value and opposite to the normal in case of negative
     *          curvature. The normal of the returned vector is equal to the
     *          absolute value of the curvature.
     */
    GEOM_Object SurfaceCurvatureByPointAndDirection (in GEOM_Object theShape,
                                                     in GEOM_Object thePoint,
                                                     in GEOM_Object theDirection);

    /*!
     *  \brief Convert X,Y,Z points coordinates to UV parameters on the given surface.
        \param theSurf the given face. It can be also a shell or a compound with one face.
        \param theXYZlist float list of size 3*N where N is the number of points
                          for which we want their U,V coordinates.
                          If the user enters a list of size not divisible by 3
                          an exception will be thrown.
        \param theIsNormalized if True, the returned parameters will be in range [0, 1].
        \return list of float of size 2*N.
     */
    ListOfDouble XYZtoUV(in GEOM_Object  theSurf,
                         in ListOfDouble theXYZlist,
                         in boolean      theIsNormalized);

    /*!
     *  \brief Convert UV parameters on the given surface to 3D points coordinates.
        \param theSurf the given face. It can be also a shell or a compound with one face.
        \param theUVlist float list of size 2*N where N is the number of points
                         for which we want their X,Y,Z coordinates.
                         If the user enters a list of non-even size
                         an exception will be thrown.
        \param theIsNormalized if True, the input parameters are expected to be in range [0, 1].
        \return list of float of size 3*N.
     */
    ListOfDouble UVtoXYZ(in GEOM_Object  theSurf,
                         in ListOfDouble theUVlist,
                         in boolean      theIsNormalized);

    //! Methods and structure for implement CheckConformity tool

    /*!
    *  \brief Structure for store shapes from failed checks.
    *         If failed check on small edges, then second shape is null
    */
    struct PairOfShape
    {
      GEOM_Object first;
      GEOM_Object second;
    };

    /*!
    *  \brief Structure for store result of check
    *  store type of check as number and failed shapes
    */
    struct CheckResult
    {
      long  type;
      PairOfShape failedShapes;
    };

    typedef sequence<PairOfShape> SequenceOfPairOfShape;
    typedef sequence<CheckResult> CheckResults;

    /*!
    *  \brief Perform analyse of shape and return all failed checks.
    *
    *  \param theShape Shape for check.
    */
    CheckResults CheckConformityShape(in GEOM_Object theShape);

    /*!
    *  \brief Find all self-intersected 2D curves.
    *
    *  \param theResults result of check - list of failed checks and sub-shapes.
    */
    SequenceOfPairOfShape SelfIntersected2D(in CheckResults theResults);

    /*!
    *  \brief Find pairs of interfering sub-shapes, by default all pairs of interfering shapes are returned.
    *         Avaliable types:
    *         - vertices touched by tolerance;
    *         - vertex touching an edge in the inner point;
    *         - vertex lying on the inner point of a face;
    *         - edges intersecting by inner points;
    *         - edge touching/intersecting face in the inner point;
    *         - faces intersection by inner point
    * 
    *  \param theResults result of check - list of failed checks and sub-shapes.
    *  \param theShapeType1 Type of shape.
    *  \param theShapeType2 Type of shape.
    */
    SequenceOfPairOfShape InterferingSubshapes(in CheckResults theResults,
                                               in long theShapeType1,
                                               in long theShapeType2);

    /*!
    *  \brief Find edges, which are fully covered by tolerances of vertices.
    *
    *  \param theResults result of check - list of failed checks and sub-shapes.
    */
    ListOfGO SmallEdges(in CheckResults theResults);

    /*!
    *  \brief find remote objects (sub-shape on a shape).
    *         Avaliable types:
    *         - vertex far from edge;
    *         - vertex far from face;
    *         - edge far from face
    *
    *  \param theResults result of check - list of failed checks and sub-shapes.
    *  \param theShapeType Type of shape.
    *  \param theSubShapeType Type of sub-shape.
    *  \param theTolerance tolerance, by default used tolerance of sub-shape.
    */
    SequenceOfPairOfShape DistantShapes(in CheckResults theResults,
                                        in long theShapeType,
                                        in long theSubShapeType,
                                        in double theTolerance);

    /*!
    *  \brief Compute possible tolerance for the shape, minimize tolerance of shape as well
    *         as tolerance of sub-shapes as much as possible
    *
    *  \param theShape Shape for update.
    */
    double UpdateTolerance(in GEOM_Object theShape);

    /*!
     *  \brief Get the calculator for the proximity value between the given shapes.
     *  \param theShape1,theShape2 Shapes to find proximity.
     *  \return The calculator object.
     */
    GEOM_Object ShapeProximityCalculator(in GEOM_Object theShape1, in GEOM_Object theShape2);

    /*!
     *  \brief Set number sample points to compute the coarse proximity.
     *  \param theCalculator Proximity calculator.
     *  \param theShape      Shape to be samples.
     *  \param theNbSamples  Number of samples points.
     */
    void SetShapeSampling(in GEOM_Object theCalculator,
                          in GEOM_Object theShape,
                          in long theNbSamples);

    /*!
     *  \brief Compute coarse value of the proximity basing on the polygonal representation of shapes.
     *  \param theCalculator Proximity calculator.
     *  \return Proximity value.
     */
    double GetCoarseProximity(in GEOM_Object theCalculator);

    /*!
     *  \brief Compute precise value of the proximity basing on the exact shapes.
     *  \param theCalculator Proximity calculator.
     *  \return Proximity value.
     */
    double GetPreciseProximity(in GEOM_Object theCalculator);

  };

 // # GEOM_IGroupOperations:
  /*!
   *  \brief Interface for groups creation.
   */
  interface GEOM_IGroupOperations : GEOM_IOperations
  {
    /*!
     *  \brief Creates a new group which will store sub-shapes of theMainShape
     *  \param theMainShape is a GEOM_Object on which the group is selected
     *  \param theShapeType defines a shape type of the group
     *  \return a newly created GEOM group
     */
    GEOM_Object CreateGroup (in GEOM_Object theMainShape, in long theShapeType);

    /*!
     *  \brief Adds a sub-object with ID theSubShapeId to the group
     *  \param theGroup is a GEOM group to which the new sub-shape is added
     *  \param theSubShapeId is a sub-shape ID in the main object.
     *  \note Use method <VAR>GEOM_IShapesOperations.GetSubShapeIndex()</VAR> to get an ID by the sub-shape
     */
    void AddObject (in GEOM_Object theGroup, in long theSubShapeId);

    /*!
     *  \brief Removes a sub-object with ID \a theSubShapeId from the group
     *  \param theGroup is a GEOM group from which the sub-shape is removed.
     *  \param theSubShapeId is a sub-shape ID in the main object.
     *  \note Use method <VAR>GEOM_IShapesOperations.GetSubShapeIndex()</VAR> to get an ID by the sub-shape
     */
    void RemoveObject (in GEOM_Object theGroup, in long theSubShapeId);

    /*!
     *  \brief Adds to the group all the given shapes. No errors, if some shapes are already included.
     *  \param theGroup is a GEOM group to which the new sub-shapes are added.
     *  \param theSubShapes is a list of sub-shapes to be added.
     */
    void UnionList (in GEOM_Object theGroup, in ListOfGO theSubShapes);

    /*!
     *  \brief Removes from the group all the given shapes. No errors, if some shapes are not included.
     *  \param theGroup is a GEOM group from which the sub-shapes are removed.
     *  \param theSubShapes is a list of sub-shapes to be removed.
     */
    void DifferenceList (in GEOM_Object theGroup, in ListOfGO theSubShapes);

    /*!
     *  \brief Adds to the group all the given shapes. No errors, if some shapes are already included.
     *  \param theGroup is a GEOM group to which the new sub-shapes are added.
     *  \param theSubShapes is a list of IDs of sub-shapes to be added.
     */
    void UnionIDs (in GEOM_Object theGroup, in ListOfLong theSubShapes);

    /*!
     *  \brief Removes from the group all the given shapes. No errors, if some shapes are not included.
     *  \param theGroup is a GEOM group from which the sub-shapes are removed.
     *  \param theSubShapes is a list of IDs of sub-shapes to be removed.
     */
    void DifferenceIDs (in GEOM_Object theGroup, in ListOfLong theSubShapes);

    /*!
     *  \brief Union of two groups.
     *  New group is created. It will contain all entities
     *  which are present in groups theGroup1 and theGroup2.
     *  \param theGroup1, theGroup2 are the initial GEOM groups
     *                              to create the united group from.
     *  \return a newly created GEOM group.
     */
    GEOM_Object UnionGroups (in GEOM_Object theGroup1, in GEOM_Object theGroup2);

    /*!
     *  \brief Intersection of two groups.
     *  New group is created. It will contain only those entities
     *  which are present in both groups theGroup1 and theGroup2.
     *  \param theGroup1, theGroup2 are the initial GEOM groups to get common part of.
     *  \return a newly created GEOM group.
     */
    GEOM_Object IntersectGroups (in GEOM_Object theGroup1, in GEOM_Object theGroup2);

    /*!
     *  \brief Cut of two groups.
     *  New group is created. It will contain entities which are
     *  present in group theGroup1 but are not present in group theGroup2.
     *  \param theGroup1 is a GEOM group to include elements of.
     *  \param theGroup2 is a GEOM group to exclude elements of.
     *  \return a newly created GEOM group.
     */
    GEOM_Object CutGroups (in GEOM_Object theGroup1, in GEOM_Object theGroup2);

    /*!
     *  \brief Union of list of groups.
     *  New group is created. It will contain all entities that are
     *  present in groups listed in theGList.
     *  \param theGList is a list of GEOM groups to create the united group from.
     *  \return a newly created GEOM group.
     */
    GEOM_Object UnionListOfGroups (in ListOfGO theGList);

    /*!
     *  \brief Intersection of list of groups.
     *  New group is created. It will contain only entities
     *  which are simultaneously present in the groups listed in theGList.
     *  \param theGList is a list of GEOM groups to get common part of.
     *  \return a newly created GEOM group.
     */
    GEOM_Object IntersectListOfGroups (in ListOfGO theGList);

    /*!
     *  \brief Cut of lists of groups.
     *  New group is created. It will contain only entities
     *  which are present in groups listed in theGList1 but 
     *  are not present in groups from theGList2.
     *  \param theGList1 is a list of GEOM groups to include elements of.
     *  \param theGList2 is a list of GEOM groups to exclude elements of.
     *  \return a newly created GEOM group.
     */
    GEOM_Object CutListOfGroups (in ListOfGO theGList1,
                                 in ListOfGO theGList2);

    /*!
     *  \brief Returns a type of sub-objects stored in the group
     *  \param theGroup is a GEOM group which type is returned.
     */
    long GetType (in GEOM_Object theGroup);

    /*!
     *  \brief Returns a main shape associated with the group
     *  \param theGroup is a GEOM group for which a main shape object is requested
     *  \return a GEOM_Object which is a main shape for theGroup
     */
    GEOM_Object GetMainShape (in GEOM_Object theGroup);

    /*!
     *  \brief Returns a list of sub-objects ID stored in the group
     *  \param theGroup is a GEOM group for which a list of IDs is requested
     */
    ListOfLong GetObjects (in GEOM_Object theGroup);
  };

  // # GEOM_IFieldOperations:
  /*!
   *  \brief Interface for field operation.
   */
  interface GEOM_IFieldOperations : GEOM_IOperations
  {
    /*!
     *  \brief Creates a field
     */
    GEOM_Field CreateField(in GEOM_Object     shape, 
                           in string          name,
                           in field_data_type type,
                           in short           dimension,
                           in string_array    componentNames);
    /*!
     *  \brief Returns number of fields on a shape
     */
    long CountFields(in GEOM_Object shape);

    /*!
     *  \brief Returns all fields on a shape
     */
    ListOfFields GetFields(in GEOM_Object shape);

    /*!
     *  \brief Returns a field on a shape by its name
     */
    GEOM_Field GetField(in GEOM_Object shape, in string name);

    /*!
     *  \brief Returns number of sub-shapes of given dimension
     */
    long GetNbSubShapes(in GEOM_Object shape, in short fieldDim);
  };

  // # GEOM_ITestOperations:
  /*!
   *  \brief Interface for testing operations.
   */
  interface GEOM_ITestOperations : GEOM_IOperations
  {
    /*!
     *  \brief Build a mesh on the given shape.
     *  \param shape is a source object
     *  \param linearDeflection is a linear deflection
     *  \param isRelative says if given value of deflection is relative to shape's bounding box
     *  \param angularDeflection is an angular deflection for edges in radians
     *  \return true in case of success; otherwise false.
     */
    boolean Tesselate(in GEOM_Object shape, in double linearDeflection,
                      in boolean isRelative, in double angularDeflection);
  };

  // # GEOM_ICanonicalRecognition:
  /*!
   *  \brief Interface for canonical recognition operations.
   */
  interface GEOM_ICanonicalRecognition : GEOM_IOperations
  {
    /*!
     * check if the shape is planar
     */
    boolean isPlane(in GEOM_Object shape, in double tolerance, inout ListOfDouble normal, inout ListOfDouble origin);

    /*!
     * check if shape is spherical
     */
    boolean isSphere(in GEOM_Object shape, in double tolerance, inout ListOfDouble origin, inout double radius);

    /*!
     * check if shape is conical
     */
    boolean isCone(in GEOM_Object shape, in double tolerance, inout ListOfDouble axis, inout ListOfDouble apex, inout double halfAngle);

    /*!
     * check if shape is cylinder
     */
    boolean isCylinder(in GEOM_Object shape, in double tolerance, inout ListOfDouble axis, inout ListOfDouble origin, inout double radius);

    /*!
     * check if edge / wire is line
     */
    boolean isLine(in GEOM_Object edge, in double tolerance, inout ListOfDouble direction, inout ListOfDouble origin);

    /*!
     * check if edge / wire is circle
     */
    boolean isCircle(in GEOM_Object edge, in double tolerance, inout ListOfDouble normal, inout ListOfDouble origin, inout double radius);

    /*!
     * check if edge / wire is ellipse
     */
    boolean isEllipse(in GEOM_Object edge, in double tolerance, inout ListOfDouble normal, inout ListOfDouble dirX, inout ListOfDouble origin, inout double majorRadius, inout double minorRadius);
  };

  // # GEOM_Gen:
  /*!
   *  \brief Interface to access other GEOM interfaces.
   *
   *  Also contains some methods to access and manage GEOM_Object.
   */
  interface GEOM_Gen : Engines::EngineComponent,SALOMEDS::Driver
  {
    /*!
     *  \brief Undo/Redo Management
     */

    void Undo ();

    void Redo ();

    /*!
     * \brief Publishing management
     *
     * Adds in theStudy a object theObject under with a name theName,
     * if theFather is not NULL the object is placed under thFather's SObject.
     * Returns a SObject where theObject is placed
     */
    SALOMEDS::SObject AddInStudy (in GEOM_BaseObject theObject,
                                  in string          theName,
                                  in GEOM_BaseObject theFather);

    /*!
     *  \brief Publish sub-shapes, standing for arguments and sub-shapes of arguments
     *
     *  To be used from python scripts out of geompy.addToStudy (non-default usage)
     *  \param theObject published GEOM_Object, arguments of which will be published
     *  \param theArgs   list of GEOM_Object, operation arguments to be published.
     *                   If this list is empty, all operation arguments will be published
     *  \param theFindMethod method to search sub-shapes, corresponding to arguments and
     *                       their sub-shapes. Value from enumeration GEOM::find_shape_method.
     *  \param theInheritFirstArg set properties of the first argument for \a theObject.
     *                            Do not publish sub-shapes in place of arguments, but only
     *                            in place of sub-shapes of the first argument,
     *                            because the whole shape corresponds to the first argument.
     *                            Mainly to be used after transformations, but it also can be
     *                            useful after partition with one object shape, and some other
     *                            operations, where only the first argument has to be considered.
     *                            If theObject has only one argument shape, this flag is automatically
     *                            considered as True, not regarding really passed value.
     *  \param theAddPrefix add prefix "from_" to names of restored sub-shapes,
     *                      and prefix "from_subshapes_of_" to names of partially restored sub-shapes.
     *  \return list of published sub-shapes
     */
    ListOfGO RestoreSubShapesO (in GEOM_Object       theObject,
                                in ListOfGO          theArgs,
                                in find_shape_method theFindMethod,
                                in boolean           theInheritFirstArg,
                                in boolean           theAddPrefix);

    /*!
     *  \brief Publish sub-shapes, standing for arguments and sub-shapes of arguments
     *
     *  To be used from python scripts out of geompy.addToStudy (non-default usage)
     *  \param theObject published GEOM_Object, arguments of which will be published
     *  \param theArgs   list of GEOM_Object, operation arguments to be published.
     *                   If this list is empty, all operation arguments will be published
     *  \param theFindMethod method to search sub-shapes, corresponding to arguments and
     *                       their sub-shapes. Value from enumeration GEOM::find_shape_method.
     *  \param theInheritFirstArg set properties of the first argument for \a theObject.
     *                            Do not publish sub-shapes in place of arguments, but only
     *                            in place of sub-shapes of the first argument,
     *                            because the whole shape corresponds to the first argument.
     *                            Mainly to be used after transformations, but it also can be
     *                            useful after partition with one object shape, and some other
     *                            operations, where only the first argument has to be considered.
     *                            If theObject has only one argument shape, this flag is automatically
     *                            considered as True, not regarding really passed value.
     *  \param theAddPrefix add prefix "from_" to names of restored sub-shapes,
     *                      and prefix "from_subshapes_of_" to names of partially restored sub-shapes.
     *  \return list of published sub-shapes
     */
    ListOfGO RestoreGivenSubShapesO (in GEOM_Object       theObject,
                                     in ListOfGO          theArgs,
                                     in find_shape_method theFindMethod,
                                     in boolean           theInheritFirstArg,
                                     in boolean           theAddPrefix);

    /*!
     *  \brief Publish sub-shapes, standing for arguments and sub-shapes of arguments
     *
     *  To be used from GUI and from geompy.addToStudy.
     *  Work like the above method, but accepts study object theSObject instead of GEOM_Object.
     *  \param theSObject study object, referencing GEOM_Object, arguments of which will be published
     *  \param theArgs   list of GEOM_Object, operation arguments to be published.
     *                   If this list is empty, all operation arguments will be published
     *  \param theFindMethod method to search sub-shapes, corresponding to arguments and
     *                       their sub-shapes. Value from enumeration GEOM::find_shape_method.
     *  \param theInheritFirstArg set properties of the first argument for \a theObject.
     *                            Do not publish sub-shapes in place of arguments, but only
     *                            in place of sub-shapes of the first argument,
     *                            because the whole shape corresponds to the first argument.
     *                            Mainly to be used after transformations, but it also can be
     *                            useful after partition with one object shape, and some other
     *                            operations, where only the first argument has to be considered.
     *                            If theObject has only one argument shape, this flag is automatically
     *                            considered as True, not regarding really passed value.
     *  \param theAddPrefix add prefix "from_" to names of restored sub-shapes,
     *                      and prefix "from_subshapes_of_" to names of partially restored sub-shapes.
     */
    ListOfGO RestoreSubShapesSO (in SALOMEDS::SObject theSObject,
                                 in ListOfGO          theArgs,
                                 in find_shape_method theFindMethod,
                                 in boolean           theInheritFirstArg,
                                 in boolean           theAddPrefix);

    // #  Methods to access interfaces for objects creation and transformation

    GEOM_IBasicOperations      GetIBasicOperations     () raises (SALOME::SALOME_Exception);
    GEOM_ITransformOperations  GetITransformOperations () raises (SALOME::SALOME_Exception);
    GEOM_I3DPrimOperations     GetI3DPrimOperations    () raises (SALOME::SALOME_Exception);
    GEOM_IShapesOperations     GetIShapesOperations    () raises (SALOME::SALOME_Exception);
    GEOM_IBooleanOperations    GetIBooleanOperations   () raises (SALOME::SALOME_Exception);
    GEOM_ICurvesOperations     GetICurvesOperations    () raises (SALOME::SALOME_Exception);
    GEOM_ILocalOperations      GetILocalOperations     () raises (SALOME::SALOME_Exception);
    GEOM_IHealingOperations    GetIHealingOperations   () raises (SALOME::SALOME_Exception);
    GEOM_IInsertOperations     GetIInsertOperations    () raises (SALOME::SALOME_Exception);
    GEOM_IMeasureOperations    GetIMeasureOperations   () raises (SALOME::SALOME_Exception);
    GEOM_IBlocksOperations     GetIBlocksOperations    () raises (SALOME::SALOME_Exception);
    GEOM_IGroupOperations      GetIGroupOperations     () raises (SALOME::SALOME_Exception);
    GEOM_IFieldOperations      GetIFieldOperations     () raises (SALOME::SALOME_Exception);
    GEOM_ITestOperations       GetITestOperations      () raises (SALOME::SALOME_Exception);
    GEOM_ICanonicalRecognition GetICanonicalRecognition() raises (SALOME::SALOME_Exception);

    GEOM_IOperations GetPluginOperations (in string theLibName) raises (SALOME::SALOME_Exception);

    // # Objects Management


    /*!
     *  \brief Removes the object from the GEOM component
     *  \param theObject is a GEOM_Object to be removed
     */
    void RemoveObject (in GEOM_BaseObject theObject);

    /*!
     *  \brief Returns an object defined by the study and its entry in the GEOM component
     *  \param theEntry is an entry of the requested GEOM_Object in the GEOM component
     *  \note if the object has not previously been created a NULL GEOM_Object is returned
     */
    GEOM_BaseObject GetObject (in string theEntry);

    /*!
     *  \brief Add a sub-shape defined by indices in \a theIndices
     *  (contains unique IDs of sub-shapes inside \a theMainShape)
     *  \note The sub-shape GEOM_Object can has ONLY ONE function.
     *        Don't try to apply modification operations on them.
     *  \note Internal method
     */
    GEOM_Object AddSubShape (in GEOM_Object theMainShape, in ListOfLong theIndices);

 // #  GEOM_Objects IOR Management
    
    /*!
     *  \brief Returns a GEOM_Object defined by its IOR
     *  \param theIOR a string containing an IOR of the requested GEOM_Object
     */
    GEOM_Object GetIORFromString (in string theIOR);

    /*!
     *  \brief Returns a string which contains an IOR of the GEOM_Object
     *  \param theObject is a GEOM_Object which IOR is requested
     */
    string GetStringFromIOR (in GEOM_Object theObject);

    /*!
     *  \brief Returns a name with which a GEOM_Object was dumped into python script
     *  \param theStudyEntry is an entry of the GEOM_Object in the study
     */
    string GetDumpName (in string theStudyEntry);

    /*!
     *  \brief Returns all names with which a GEOM_Object was dumped
     *  into python script to avoid the same names in SMESH script
     */
    string_array GetAllDumpNames();

    /*!
     *  \brief Publishes the named sub-shapes of given object in the study.
     *  \param theObject   The object which named sub-shapes are published
     */
    ListOfGO PublishNamedShapesInStudy(//in SObject theSObject,
                                       in Object theObject);

    /*!
     * \brief Creates a new folder
     *
     * Creates a new container (folder) for any GEOM objects.
     * Folder will have name theName.
     * If theFather is not NULL, the folder is placed under theFather object.
     * Otherwise, the folder takes place under root 'Geometry' object.
     * 
     * \param theName name of the folder
     * \param theFather parent object
     * \return SObject represented the created folder.
     */
    SALOMEDS::SObject CreateFolder (in string theName,
				    in SALOMEDS::SObject theFather);

    /*!
     * \brief Moves object to the specified folder
     *
     * The moved object should be first published in the study.
     * \param theObject GEOM object to move
     * \param theFolder target folder
     */
    void MoveToFolder (in GEOM_Object theObject,
		       in SALOMEDS::SObject theFolder);

    /*!
     * \brief Moves list of objects to the specified folder
     *
     * The moved objects should be first published in the study.
     * \param theListOfGO list of GEOM objects to move
     * \param theFolder target folder
     */
    void MoveListToFolder (in ListOfGO theListOfGO,
			   in SALOMEDS::SObject theFolder);

    /*!
     * \brief Moves objects to the specified position
     *
     * This function is used in the drag-n-drop functionality.
     *
     * \param what objects being moved
     * \param where parent object where objects are moved to
     * \param row position in the parent object's children list at which objects are moved
     */
    void Move( in object_list what, 
	       in SALOMEDS::SObject where, 
	       in long row );

    /*!
     * \brief Collects dependencies of the given objects from other ones
     * \param theListOfEntries List of GEOM object entries in OCAF tree (not in study)
     * \return Struct of dependent entries and its links as a byte array
     * \note This method is supposed to be used by GUI only.
     */
    SALOMEDS::TMPFile GetDependencyTree(in string_array theListOfEntries);

    /*!
     * \brief Fills 3 lists that is used to reduce study of redundant objects:
     *  - dependencies of the given objects from other ones;
     *  - children of the given objects;
     *  - all other objects in study.
     * \param theSelectedEntries List of GEOM object entries in OCAF tree
     * \param theParentEntries List of GEOM object entries on which the given objects depend
     * \param theSubEntries Children entries list of the given objects
     * \param theOtherEntries List of GEOM object entries which are in the study, but not in parents and children lists
     * \note This method is supposed to be used by GUI only.
     */
    void GetEntriesToReduceStudy(inout string_array theSelectedEntries,
				                 inout string_array theParentEntries,
				                 inout string_array theSubEntries,
				                 inout string_array theOtherEntries);


    /*
    * \brief Breaks links to parametrical mode for parametrical shape
    */
    void BreakLink(in string theEntry);
  };
};

#endif
